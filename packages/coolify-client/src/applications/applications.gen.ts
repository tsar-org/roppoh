/**
 * Generated by orval v7.12.2 üç∫
 * Do not edit manually.
 * Coolify
 * OpenAPI spec version: 0.1
 */

import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";

import type {
  ApplicationDTO,
  CreateDockercomposeApplication201,
  CreateDockercomposeApplication409,
  CreateDockercomposeApplicationBodies,
  CreateDockerfileApplication201,
  CreateDockerfileApplication409,
  CreateDockerfileApplicationBodies,
  CreateDockerimageApplication201,
  CreateDockerimageApplication409,
  CreateDockerimageApplicationBodies,
  CreateEnvByApplicationUuid201,
  CreateEnvByApplicationUuidBodies,
  CreatePrivateDeployKeyApplication201,
  CreatePrivateDeployKeyApplication409,
  CreatePrivateDeployKeyApplicationBodies,
  CreatePrivateGithubAppApplication201,
  CreatePrivateGithubAppApplication409,
  CreatePrivateGithubAppApplicationBodies,
  CreatePublicApplication201,
  CreatePublicApplication409,
  CreatePublicApplicationBodies,
  DeleteApplicationByUuid200,
  DeleteApplicationByUuidParams,
  DeleteEnvByApplicationUuid200,
  EnvironmentVariableDTO,
  GetApplicationLogsByUuid200,
  GetApplicationLogsByUuidParams,
  NHttp400Response,
  NHttp401Response,
  NHttp404Response,
  RestartApplicationByUuid200,
  StartApplicationByUuid200,
  StartApplicationByUuidParams,
  StopApplicationByUuid200,
  UpdateApplicationByUuid200,
  UpdateApplicationByUuid409,
  UpdateApplicationByUuidBodies,
  UpdateEnvByApplicationUuid201,
  UpdateEnvByApplicationUuidBodies,
  UpdateEnvsByApplicationUuid201,
  UpdateEnvsByApplicationUuidBodies,
} from ".././model";

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

/**
 * List all applications.
 * @summary List
 */
export type listApplicationsResponse200 = {
  data: ApplicationDTO[];
  status: 200;
};

export type listApplicationsResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type listApplicationsResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type listApplicationsResponseSuccess = listApplicationsResponse200 & {
  headers: Headers;
};
export type listApplicationsResponseError = (
  | listApplicationsResponse400
  | listApplicationsResponse401
) & {
  headers: Headers;
};

export type listApplicationsResponse =
  | listApplicationsResponseSuccess
  | listApplicationsResponseError;

export const getListApplicationsUrl = () => {
  return `/api/coolify/applications`;
};

export const listApplications = async (
  options?: RequestInit,
): Promise<listApplicationsResponse> => {
  const res = await fetch(getListApplicationsUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: listApplicationsResponse["data"] = body ? JSON.parse(body) : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as listApplicationsResponse;
};

export const getListApplicationsQueryKey = () => {
  return [`/api/coolify/applications`] as const;
};

export const getListApplicationsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof listApplications>>>,
  TError = NHttp400Response | NHttp401Response,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof listApplications>>,
      TError,
      TData
    >
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListApplicationsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listApplications>>
  > = ({ signal }) => listApplications({ signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof listApplications>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListApplicationsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof listApplications>>
>;
export type ListApplicationsInfiniteQueryError =
  | NHttp400Response
  | NHttp401Response;

export function useListApplicationsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof listApplications>>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listApplications>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listApplications>>,
          TError,
          Awaited<ReturnType<typeof listApplications>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListApplicationsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof listApplications>>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listApplications>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listApplications>>,
          TError,
          Awaited<ReturnType<typeof listApplications>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListApplicationsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof listApplications>>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listApplications>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List
 */

export function useListApplicationsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof listApplications>>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listApplications>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getListApplicationsInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary List
 */
export const prefetchListApplicationsInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof listApplications>>,
  TError = NHttp400Response | NHttp401Response,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listApplications>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getListApplicationsInfiniteQueryOptions(options);

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const getListApplicationsQueryOptions = <
  TData = Awaited<ReturnType<typeof listApplications>>,
  TError = NHttp400Response | NHttp401Response,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listApplications>>, TError, TData>
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListApplicationsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listApplications>>
  > = ({ signal }) => listApplications({ signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof listApplications>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListApplicationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listApplications>>
>;
export type ListApplicationsQueryError = NHttp400Response | NHttp401Response;

export function useListApplications<
  TData = Awaited<ReturnType<typeof listApplications>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listApplications>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listApplications>>,
          TError,
          Awaited<ReturnType<typeof listApplications>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListApplications<
  TData = Awaited<ReturnType<typeof listApplications>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listApplications>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listApplications>>,
          TError,
          Awaited<ReturnType<typeof listApplications>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListApplications<
  TData = Awaited<ReturnType<typeof listApplications>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listApplications>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List
 */

export function useListApplications<
  TData = Awaited<ReturnType<typeof listApplications>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listApplications>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getListApplicationsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary List
 */
export const prefetchListApplicationsQuery = async <
  TData = Awaited<ReturnType<typeof listApplications>>,
  TError = NHttp400Response | NHttp401Response,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listApplications>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getListApplicationsQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getListApplicationsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof listApplications>>,
  TError = NHttp400Response | NHttp401Response,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof listApplications>>,
      TError,
      TData
    >
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListApplicationsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listApplications>>
  > = ({ signal }) => listApplications({ signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof listApplications>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListApplicationsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof listApplications>>
>;
export type ListApplicationsSuspenseQueryError =
  | NHttp400Response
  | NHttp401Response;

export function useListApplicationsSuspense<
  TData = Awaited<ReturnType<typeof listApplications>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof listApplications>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListApplicationsSuspense<
  TData = Awaited<ReturnType<typeof listApplications>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof listApplications>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListApplicationsSuspense<
  TData = Awaited<ReturnType<typeof listApplications>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof listApplications>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List
 */

export function useListApplicationsSuspense<
  TData = Awaited<ReturnType<typeof listApplications>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof listApplications>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getListApplicationsSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create new application based on a public git repository.
 * @summary Create (Public)
 */
export type createPublicApplicationResponse201 = {
  data: CreatePublicApplication201;
  status: 201;
};

export type createPublicApplicationResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type createPublicApplicationResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type createPublicApplicationResponse409 = {
  data: CreatePublicApplication409;
  status: 409;
};

export type createPublicApplicationResponseSuccess =
  createPublicApplicationResponse201 & {
    headers: Headers;
  };
export type createPublicApplicationResponseError = (
  | createPublicApplicationResponse400
  | createPublicApplicationResponse401
  | createPublicApplicationResponse409
) & {
  headers: Headers;
};

export type createPublicApplicationResponse =
  | createPublicApplicationResponseSuccess
  | createPublicApplicationResponseError;

export const getCreatePublicApplicationUrl = () => {
  return `/api/coolify/applications/public`;
};

export const createPublicApplication = async (
  createPublicApplicationBodies: CreatePublicApplicationBodies,
  options?: RequestInit,
): Promise<createPublicApplicationResponse> => {
  const res = await fetch(getCreatePublicApplicationUrl(), {
    ...options,
    body: JSON.stringify(createPublicApplicationBodies),
    headers: { "Content-Type": "application/json", ...options?.headers },
    method: "POST",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: createPublicApplicationResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as createPublicApplicationResponse;
};

export const getCreatePublicApplicationMutationOptions = <
  TError = NHttp400Response | NHttp401Response | CreatePublicApplication409,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createPublicApplication>>,
    TError,
    { data: CreatePublicApplicationBodies },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createPublicApplication>>,
  TError,
  { data: CreatePublicApplicationBodies },
  TContext
> => {
  const mutationKey = ["createPublicApplication"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { fetch: undefined, mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createPublicApplication>>,
    { data: CreatePublicApplicationBodies }
  > = (props) => {
    const { data } = props ?? {};

    return createPublicApplication(data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreatePublicApplicationMutationResult = NonNullable<
  Awaited<ReturnType<typeof createPublicApplication>>
>;
export type CreatePublicApplicationMutationBody = CreatePublicApplicationBodies;
export type CreatePublicApplicationMutationError =
  | NHttp400Response
  | NHttp401Response
  | CreatePublicApplication409;

/**
 * @summary Create (Public)
 */
export const useCreatePublicApplication = <
  TError = NHttp400Response | NHttp401Response | CreatePublicApplication409,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createPublicApplication>>,
      TError,
      { data: CreatePublicApplicationBodies },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createPublicApplication>>,
  TError,
  { data: CreatePublicApplicationBodies },
  TContext
> => {
  const mutationOptions = getCreatePublicApplicationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Create new application based on a private repository through a Github App.
 * @summary Create (Private - GH App)
 */
export type createPrivateGithubAppApplicationResponse201 = {
  data: CreatePrivateGithubAppApplication201;
  status: 201;
};

export type createPrivateGithubAppApplicationResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type createPrivateGithubAppApplicationResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type createPrivateGithubAppApplicationResponse409 = {
  data: CreatePrivateGithubAppApplication409;
  status: 409;
};

export type createPrivateGithubAppApplicationResponseSuccess =
  createPrivateGithubAppApplicationResponse201 & {
    headers: Headers;
  };
export type createPrivateGithubAppApplicationResponseError = (
  | createPrivateGithubAppApplicationResponse400
  | createPrivateGithubAppApplicationResponse401
  | createPrivateGithubAppApplicationResponse409
) & {
  headers: Headers;
};

export type createPrivateGithubAppApplicationResponse =
  | createPrivateGithubAppApplicationResponseSuccess
  | createPrivateGithubAppApplicationResponseError;

export const getCreatePrivateGithubAppApplicationUrl = () => {
  return `/api/coolify/applications/private-github-app`;
};

export const createPrivateGithubAppApplication = async (
  createPrivateGithubAppApplicationBodies: CreatePrivateGithubAppApplicationBodies,
  options?: RequestInit,
): Promise<createPrivateGithubAppApplicationResponse> => {
  const res = await fetch(getCreatePrivateGithubAppApplicationUrl(), {
    ...options,
    body: JSON.stringify(createPrivateGithubAppApplicationBodies),
    headers: { "Content-Type": "application/json", ...options?.headers },
    method: "POST",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: createPrivateGithubAppApplicationResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as createPrivateGithubAppApplicationResponse;
};

export const getCreatePrivateGithubAppApplicationMutationOptions = <
  TError =
    | NHttp400Response
    | NHttp401Response
    | CreatePrivateGithubAppApplication409,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createPrivateGithubAppApplication>>,
    TError,
    { data: CreatePrivateGithubAppApplicationBodies },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createPrivateGithubAppApplication>>,
  TError,
  { data: CreatePrivateGithubAppApplicationBodies },
  TContext
> => {
  const mutationKey = ["createPrivateGithubAppApplication"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { fetch: undefined, mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createPrivateGithubAppApplication>>,
    { data: CreatePrivateGithubAppApplicationBodies }
  > = (props) => {
    const { data } = props ?? {};

    return createPrivateGithubAppApplication(data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreatePrivateGithubAppApplicationMutationResult = NonNullable<
  Awaited<ReturnType<typeof createPrivateGithubAppApplication>>
>;
export type CreatePrivateGithubAppApplicationMutationBody =
  CreatePrivateGithubAppApplicationBodies;
export type CreatePrivateGithubAppApplicationMutationError =
  | NHttp400Response
  | NHttp401Response
  | CreatePrivateGithubAppApplication409;

/**
 * @summary Create (Private - GH App)
 */
export const useCreatePrivateGithubAppApplication = <
  TError =
    | NHttp400Response
    | NHttp401Response
    | CreatePrivateGithubAppApplication409,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createPrivateGithubAppApplication>>,
      TError,
      { data: CreatePrivateGithubAppApplicationBodies },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createPrivateGithubAppApplication>>,
  TError,
  { data: CreatePrivateGithubAppApplicationBodies },
  TContext
> => {
  const mutationOptions =
    getCreatePrivateGithubAppApplicationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Create new application based on a private repository through a Deploy Key.
 * @summary Create (Private - Deploy Key)
 */
export type createPrivateDeployKeyApplicationResponse201 = {
  data: CreatePrivateDeployKeyApplication201;
  status: 201;
};

export type createPrivateDeployKeyApplicationResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type createPrivateDeployKeyApplicationResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type createPrivateDeployKeyApplicationResponse409 = {
  data: CreatePrivateDeployKeyApplication409;
  status: 409;
};

export type createPrivateDeployKeyApplicationResponseSuccess =
  createPrivateDeployKeyApplicationResponse201 & {
    headers: Headers;
  };
export type createPrivateDeployKeyApplicationResponseError = (
  | createPrivateDeployKeyApplicationResponse400
  | createPrivateDeployKeyApplicationResponse401
  | createPrivateDeployKeyApplicationResponse409
) & {
  headers: Headers;
};

export type createPrivateDeployKeyApplicationResponse =
  | createPrivateDeployKeyApplicationResponseSuccess
  | createPrivateDeployKeyApplicationResponseError;

export const getCreatePrivateDeployKeyApplicationUrl = () => {
  return `/api/coolify/applications/private-deploy-key`;
};

export const createPrivateDeployKeyApplication = async (
  createPrivateDeployKeyApplicationBodies: CreatePrivateDeployKeyApplicationBodies,
  options?: RequestInit,
): Promise<createPrivateDeployKeyApplicationResponse> => {
  const res = await fetch(getCreatePrivateDeployKeyApplicationUrl(), {
    ...options,
    body: JSON.stringify(createPrivateDeployKeyApplicationBodies),
    headers: { "Content-Type": "application/json", ...options?.headers },
    method: "POST",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: createPrivateDeployKeyApplicationResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as createPrivateDeployKeyApplicationResponse;
};

export const getCreatePrivateDeployKeyApplicationMutationOptions = <
  TError =
    | NHttp400Response
    | NHttp401Response
    | CreatePrivateDeployKeyApplication409,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createPrivateDeployKeyApplication>>,
    TError,
    { data: CreatePrivateDeployKeyApplicationBodies },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createPrivateDeployKeyApplication>>,
  TError,
  { data: CreatePrivateDeployKeyApplicationBodies },
  TContext
> => {
  const mutationKey = ["createPrivateDeployKeyApplication"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { fetch: undefined, mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createPrivateDeployKeyApplication>>,
    { data: CreatePrivateDeployKeyApplicationBodies }
  > = (props) => {
    const { data } = props ?? {};

    return createPrivateDeployKeyApplication(data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreatePrivateDeployKeyApplicationMutationResult = NonNullable<
  Awaited<ReturnType<typeof createPrivateDeployKeyApplication>>
>;
export type CreatePrivateDeployKeyApplicationMutationBody =
  CreatePrivateDeployKeyApplicationBodies;
export type CreatePrivateDeployKeyApplicationMutationError =
  | NHttp400Response
  | NHttp401Response
  | CreatePrivateDeployKeyApplication409;

/**
 * @summary Create (Private - Deploy Key)
 */
export const useCreatePrivateDeployKeyApplication = <
  TError =
    | NHttp400Response
    | NHttp401Response
    | CreatePrivateDeployKeyApplication409,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createPrivateDeployKeyApplication>>,
      TError,
      { data: CreatePrivateDeployKeyApplicationBodies },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createPrivateDeployKeyApplication>>,
  TError,
  { data: CreatePrivateDeployKeyApplicationBodies },
  TContext
> => {
  const mutationOptions =
    getCreatePrivateDeployKeyApplicationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Create new application based on a simple Dockerfile.
 * @summary Create (Dockerfile)
 */
export type createDockerfileApplicationResponse201 = {
  data: CreateDockerfileApplication201;
  status: 201;
};

export type createDockerfileApplicationResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type createDockerfileApplicationResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type createDockerfileApplicationResponse409 = {
  data: CreateDockerfileApplication409;
  status: 409;
};

export type createDockerfileApplicationResponseSuccess =
  createDockerfileApplicationResponse201 & {
    headers: Headers;
  };
export type createDockerfileApplicationResponseError = (
  | createDockerfileApplicationResponse400
  | createDockerfileApplicationResponse401
  | createDockerfileApplicationResponse409
) & {
  headers: Headers;
};

export type createDockerfileApplicationResponse =
  | createDockerfileApplicationResponseSuccess
  | createDockerfileApplicationResponseError;

export const getCreateDockerfileApplicationUrl = () => {
  return `/api/coolify/applications/dockerfile`;
};

export const createDockerfileApplication = async (
  createDockerfileApplicationBodies: CreateDockerfileApplicationBodies,
  options?: RequestInit,
): Promise<createDockerfileApplicationResponse> => {
  const res = await fetch(getCreateDockerfileApplicationUrl(), {
    ...options,
    body: JSON.stringify(createDockerfileApplicationBodies),
    headers: { "Content-Type": "application/json", ...options?.headers },
    method: "POST",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: createDockerfileApplicationResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as createDockerfileApplicationResponse;
};

export const getCreateDockerfileApplicationMutationOptions = <
  TError = NHttp400Response | NHttp401Response | CreateDockerfileApplication409,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createDockerfileApplication>>,
    TError,
    { data: CreateDockerfileApplicationBodies },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createDockerfileApplication>>,
  TError,
  { data: CreateDockerfileApplicationBodies },
  TContext
> => {
  const mutationKey = ["createDockerfileApplication"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { fetch: undefined, mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createDockerfileApplication>>,
    { data: CreateDockerfileApplicationBodies }
  > = (props) => {
    const { data } = props ?? {};

    return createDockerfileApplication(data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateDockerfileApplicationMutationResult = NonNullable<
  Awaited<ReturnType<typeof createDockerfileApplication>>
>;
export type CreateDockerfileApplicationMutationBody =
  CreateDockerfileApplicationBodies;
export type CreateDockerfileApplicationMutationError =
  | NHttp400Response
  | NHttp401Response
  | CreateDockerfileApplication409;

/**
 * @summary Create (Dockerfile)
 */
export const useCreateDockerfileApplication = <
  TError = NHttp400Response | NHttp401Response | CreateDockerfileApplication409,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createDockerfileApplication>>,
      TError,
      { data: CreateDockerfileApplicationBodies },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createDockerfileApplication>>,
  TError,
  { data: CreateDockerfileApplicationBodies },
  TContext
> => {
  const mutationOptions =
    getCreateDockerfileApplicationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Create new application based on a prebuilt docker image
 * @summary Create (Docker Image)
 */
export type createDockerimageApplicationResponse201 = {
  data: CreateDockerimageApplication201;
  status: 201;
};

export type createDockerimageApplicationResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type createDockerimageApplicationResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type createDockerimageApplicationResponse409 = {
  data: CreateDockerimageApplication409;
  status: 409;
};

export type createDockerimageApplicationResponseSuccess =
  createDockerimageApplicationResponse201 & {
    headers: Headers;
  };
export type createDockerimageApplicationResponseError = (
  | createDockerimageApplicationResponse400
  | createDockerimageApplicationResponse401
  | createDockerimageApplicationResponse409
) & {
  headers: Headers;
};

export type createDockerimageApplicationResponse =
  | createDockerimageApplicationResponseSuccess
  | createDockerimageApplicationResponseError;

export const getCreateDockerimageApplicationUrl = () => {
  return `/api/coolify/applications/dockerimage`;
};

export const createDockerimageApplication = async (
  createDockerimageApplicationBodies: CreateDockerimageApplicationBodies,
  options?: RequestInit,
): Promise<createDockerimageApplicationResponse> => {
  const res = await fetch(getCreateDockerimageApplicationUrl(), {
    ...options,
    body: JSON.stringify(createDockerimageApplicationBodies),
    headers: { "Content-Type": "application/json", ...options?.headers },
    method: "POST",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: createDockerimageApplicationResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as createDockerimageApplicationResponse;
};

export const getCreateDockerimageApplicationMutationOptions = <
  TError =
    | NHttp400Response
    | NHttp401Response
    | CreateDockerimageApplication409,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createDockerimageApplication>>,
    TError,
    { data: CreateDockerimageApplicationBodies },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createDockerimageApplication>>,
  TError,
  { data: CreateDockerimageApplicationBodies },
  TContext
> => {
  const mutationKey = ["createDockerimageApplication"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { fetch: undefined, mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createDockerimageApplication>>,
    { data: CreateDockerimageApplicationBodies }
  > = (props) => {
    const { data } = props ?? {};

    return createDockerimageApplication(data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateDockerimageApplicationMutationResult = NonNullable<
  Awaited<ReturnType<typeof createDockerimageApplication>>
>;
export type CreateDockerimageApplicationMutationBody =
  CreateDockerimageApplicationBodies;
export type CreateDockerimageApplicationMutationError =
  | NHttp400Response
  | NHttp401Response
  | CreateDockerimageApplication409;

/**
 * @summary Create (Docker Image)
 */
export const useCreateDockerimageApplication = <
  TError =
    | NHttp400Response
    | NHttp401Response
    | CreateDockerimageApplication409,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createDockerimageApplication>>,
      TError,
      { data: CreateDockerimageApplicationBodies },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createDockerimageApplication>>,
  TError,
  { data: CreateDockerimageApplicationBodies },
  TContext
> => {
  const mutationOptions =
    getCreateDockerimageApplicationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Create new application based on a docker-compose file.
 * @summary Create (Docker Compose)
 */
export type createDockercomposeApplicationResponse201 = {
  data: CreateDockercomposeApplication201;
  status: 201;
};

export type createDockercomposeApplicationResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type createDockercomposeApplicationResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type createDockercomposeApplicationResponse409 = {
  data: CreateDockercomposeApplication409;
  status: 409;
};

export type createDockercomposeApplicationResponseSuccess =
  createDockercomposeApplicationResponse201 & {
    headers: Headers;
  };
export type createDockercomposeApplicationResponseError = (
  | createDockercomposeApplicationResponse400
  | createDockercomposeApplicationResponse401
  | createDockercomposeApplicationResponse409
) & {
  headers: Headers;
};

export type createDockercomposeApplicationResponse =
  | createDockercomposeApplicationResponseSuccess
  | createDockercomposeApplicationResponseError;

export const getCreateDockercomposeApplicationUrl = () => {
  return `/api/coolify/applications/dockercompose`;
};

export const createDockercomposeApplication = async (
  createDockercomposeApplicationBodies: CreateDockercomposeApplicationBodies,
  options?: RequestInit,
): Promise<createDockercomposeApplicationResponse> => {
  const res = await fetch(getCreateDockercomposeApplicationUrl(), {
    ...options,
    body: JSON.stringify(createDockercomposeApplicationBodies),
    headers: { "Content-Type": "application/json", ...options?.headers },
    method: "POST",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: createDockercomposeApplicationResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as createDockercomposeApplicationResponse;
};

export const getCreateDockercomposeApplicationMutationOptions = <
  TError =
    | NHttp400Response
    | NHttp401Response
    | CreateDockercomposeApplication409,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createDockercomposeApplication>>,
    TError,
    { data: CreateDockercomposeApplicationBodies },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createDockercomposeApplication>>,
  TError,
  { data: CreateDockercomposeApplicationBodies },
  TContext
> => {
  const mutationKey = ["createDockercomposeApplication"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { fetch: undefined, mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createDockercomposeApplication>>,
    { data: CreateDockercomposeApplicationBodies }
  > = (props) => {
    const { data } = props ?? {};

    return createDockercomposeApplication(data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateDockercomposeApplicationMutationResult = NonNullable<
  Awaited<ReturnType<typeof createDockercomposeApplication>>
>;
export type CreateDockercomposeApplicationMutationBody =
  CreateDockercomposeApplicationBodies;
export type CreateDockercomposeApplicationMutationError =
  | NHttp400Response
  | NHttp401Response
  | CreateDockercomposeApplication409;

/**
 * @summary Create (Docker Compose)
 */
export const useCreateDockercomposeApplication = <
  TError =
    | NHttp400Response
    | NHttp401Response
    | CreateDockercomposeApplication409,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createDockercomposeApplication>>,
      TError,
      { data: CreateDockercomposeApplicationBodies },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createDockercomposeApplication>>,
  TError,
  { data: CreateDockercomposeApplicationBodies },
  TContext
> => {
  const mutationOptions =
    getCreateDockercomposeApplicationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Get application by UUID.
 * @summary Get
 */
export type getApplicationByUuidResponse200 = {
  data: ApplicationDTO;
  status: 200;
};

export type getApplicationByUuidResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type getApplicationByUuidResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type getApplicationByUuidResponse404 = {
  data: NHttp404Response;
  status: 404;
};

export type getApplicationByUuidResponseSuccess =
  getApplicationByUuidResponse200 & {
    headers: Headers;
  };
export type getApplicationByUuidResponseError = (
  | getApplicationByUuidResponse400
  | getApplicationByUuidResponse401
  | getApplicationByUuidResponse404
) & {
  headers: Headers;
};

export type getApplicationByUuidResponse =
  | getApplicationByUuidResponseSuccess
  | getApplicationByUuidResponseError;

export const getGetApplicationByUuidUrl = (uuid: string) => {
  return `/api/coolify/applications/${uuid}`;
};

export const getApplicationByUuid = async (
  uuid: string,
  options?: RequestInit,
): Promise<getApplicationByUuidResponse> => {
  const res = await fetch(getGetApplicationByUuidUrl(uuid), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getApplicationByUuidResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as getApplicationByUuidResponse;
};

export const getGetApplicationByUuidQueryKey = (uuid?: string) => {
  return [`/api/coolify/applications/${uuid}`] as const;
};

export const getGetApplicationByUuidInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getApplicationByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetApplicationByUuidQueryKey(uuid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getApplicationByUuid>>
  > = ({ signal }) => getApplicationByUuid(uuid, { signal, ...fetchOptions });

  return {
    enabled: !!uuid,
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getApplicationByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetApplicationByUuidInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getApplicationByUuid>>
>;
export type GetApplicationByUuidInfiniteQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useGetApplicationByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getApplicationByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getApplicationByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApplicationByUuid>>,
          TError,
          Awaited<ReturnType<typeof getApplicationByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetApplicationByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getApplicationByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getApplicationByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApplicationByUuid>>,
          TError,
          Awaited<ReturnType<typeof getApplicationByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetApplicationByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getApplicationByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get
 */

export function useGetApplicationByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getApplicationByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetApplicationByUuidInfiniteQueryOptions(
    uuid,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get
 */
export const prefetchGetApplicationByUuidInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  queryClient: QueryClient,
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetApplicationByUuidInfiniteQueryOptions(
    uuid,
    options,
  );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const getGetApplicationByUuidQueryOptions = <
  TData = Awaited<ReturnType<typeof getApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetApplicationByUuidQueryKey(uuid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getApplicationByUuid>>
  > = ({ signal }) => getApplicationByUuid(uuid, { signal, ...fetchOptions });

  return {
    enabled: !!uuid,
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getApplicationByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetApplicationByUuidQueryResult = NonNullable<
  Awaited<ReturnType<typeof getApplicationByUuid>>
>;
export type GetApplicationByUuidQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useGetApplicationByUuid<
  TData = Awaited<ReturnType<typeof getApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApplicationByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApplicationByUuid>>,
          TError,
          Awaited<ReturnType<typeof getApplicationByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetApplicationByUuid<
  TData = Awaited<ReturnType<typeof getApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApplicationByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApplicationByUuid>>,
          TError,
          Awaited<ReturnType<typeof getApplicationByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetApplicationByUuid<
  TData = Awaited<ReturnType<typeof getApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get
 */

export function useGetApplicationByUuid<
  TData = Awaited<ReturnType<typeof getApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetApplicationByUuidQueryOptions(uuid, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get
 */
export const prefetchGetApplicationByUuidQuery = async <
  TData = Awaited<ReturnType<typeof getApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  queryClient: QueryClient,
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetApplicationByUuidQueryOptions(uuid, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getGetApplicationByUuidSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetApplicationByUuidQueryKey(uuid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getApplicationByUuid>>
  > = ({ signal }) => getApplicationByUuid(uuid, { signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getApplicationByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetApplicationByUuidSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getApplicationByUuid>>
>;
export type GetApplicationByUuidSuspenseQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useGetApplicationByUuidSuspense<
  TData = Awaited<ReturnType<typeof getApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetApplicationByUuidSuspense<
  TData = Awaited<ReturnType<typeof getApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetApplicationByUuidSuspense<
  TData = Awaited<ReturnType<typeof getApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get
 */

export function useGetApplicationByUuidSuspense<
  TData = Awaited<ReturnType<typeof getApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetApplicationByUuidSuspenseQueryOptions(
    uuid,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete application by UUID.
 * @summary Delete
 */
export type deleteApplicationByUuidResponse200 = {
  data: DeleteApplicationByUuid200;
  status: 200;
};

export type deleteApplicationByUuidResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type deleteApplicationByUuidResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type deleteApplicationByUuidResponse404 = {
  data: NHttp404Response;
  status: 404;
};

export type deleteApplicationByUuidResponseSuccess =
  deleteApplicationByUuidResponse200 & {
    headers: Headers;
  };
export type deleteApplicationByUuidResponseError = (
  | deleteApplicationByUuidResponse400
  | deleteApplicationByUuidResponse401
  | deleteApplicationByUuidResponse404
) & {
  headers: Headers;
};

export type deleteApplicationByUuidResponse =
  | deleteApplicationByUuidResponseSuccess
  | deleteApplicationByUuidResponseError;

export const getDeleteApplicationByUuidUrl = (
  uuid: string,
  params?: DeleteApplicationByUuidParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/coolify/applications/${uuid}?${stringifiedParams}`
    : `/api/coolify/applications/${uuid}`;
};

export const deleteApplicationByUuid = async (
  uuid: string,
  params?: DeleteApplicationByUuidParams,
  options?: RequestInit,
): Promise<deleteApplicationByUuidResponse> => {
  const res = await fetch(getDeleteApplicationByUuidUrl(uuid, params), {
    ...options,
    method: "DELETE",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: deleteApplicationByUuidResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as deleteApplicationByUuidResponse;
};

export const getDeleteApplicationByUuidMutationOptions = <
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteApplicationByUuid>>,
    TError,
    { uuid: string; params?: DeleteApplicationByUuidParams },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteApplicationByUuid>>,
  TError,
  { uuid: string; params?: DeleteApplicationByUuidParams },
  TContext
> => {
  const mutationKey = ["deleteApplicationByUuid"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { fetch: undefined, mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteApplicationByUuid>>,
    { uuid: string; params?: DeleteApplicationByUuidParams }
  > = (props) => {
    const { uuid, params } = props ?? {};

    return deleteApplicationByUuid(uuid, params, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteApplicationByUuidMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteApplicationByUuid>>
>;

export type DeleteApplicationByUuidMutationError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

/**
 * @summary Delete
 */
export const useDeleteApplicationByUuid = <
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteApplicationByUuid>>,
      TError,
      { uuid: string; params?: DeleteApplicationByUuidParams },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteApplicationByUuid>>,
  TError,
  { uuid: string; params?: DeleteApplicationByUuidParams },
  TContext
> => {
  const mutationOptions = getDeleteApplicationByUuidMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Update application by UUID.
 * @summary Update
 */
export type updateApplicationByUuidResponse200 = {
  data: UpdateApplicationByUuid200;
  status: 200;
};

export type updateApplicationByUuidResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type updateApplicationByUuidResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type updateApplicationByUuidResponse404 = {
  data: NHttp404Response;
  status: 404;
};

export type updateApplicationByUuidResponse409 = {
  data: UpdateApplicationByUuid409;
  status: 409;
};

export type updateApplicationByUuidResponseSuccess =
  updateApplicationByUuidResponse200 & {
    headers: Headers;
  };
export type updateApplicationByUuidResponseError = (
  | updateApplicationByUuidResponse400
  | updateApplicationByUuidResponse401
  | updateApplicationByUuidResponse404
  | updateApplicationByUuidResponse409
) & {
  headers: Headers;
};

export type updateApplicationByUuidResponse =
  | updateApplicationByUuidResponseSuccess
  | updateApplicationByUuidResponseError;

export const getUpdateApplicationByUuidUrl = (uuid: string) => {
  return `/api/coolify/applications/${uuid}`;
};

export const updateApplicationByUuid = async (
  uuid: string,
  updateApplicationByUuidBodies: UpdateApplicationByUuidBodies,
  options?: RequestInit,
): Promise<updateApplicationByUuidResponse> => {
  const res = await fetch(getUpdateApplicationByUuidUrl(uuid), {
    ...options,
    body: JSON.stringify(updateApplicationByUuidBodies),
    headers: { "Content-Type": "application/json", ...options?.headers },
    method: "PATCH",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: updateApplicationByUuidResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as updateApplicationByUuidResponse;
};

export const getUpdateApplicationByUuidMutationOptions = <
  TError =
    | NHttp400Response
    | NHttp401Response
    | NHttp404Response
    | UpdateApplicationByUuid409,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateApplicationByUuid>>,
    TError,
    { uuid: string; data: UpdateApplicationByUuidBodies },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateApplicationByUuid>>,
  TError,
  { uuid: string; data: UpdateApplicationByUuidBodies },
  TContext
> => {
  const mutationKey = ["updateApplicationByUuid"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { fetch: undefined, mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateApplicationByUuid>>,
    { uuid: string; data: UpdateApplicationByUuidBodies }
  > = (props) => {
    const { uuid, data } = props ?? {};

    return updateApplicationByUuid(uuid, data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateApplicationByUuidMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateApplicationByUuid>>
>;
export type UpdateApplicationByUuidMutationBody = UpdateApplicationByUuidBodies;
export type UpdateApplicationByUuidMutationError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response
  | UpdateApplicationByUuid409;

/**
 * @summary Update
 */
export const useUpdateApplicationByUuid = <
  TError =
    | NHttp400Response
    | NHttp401Response
    | NHttp404Response
    | UpdateApplicationByUuid409,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateApplicationByUuid>>,
      TError,
      { uuid: string; data: UpdateApplicationByUuidBodies },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateApplicationByUuid>>,
  TError,
  { uuid: string; data: UpdateApplicationByUuidBodies },
  TContext
> => {
  const mutationOptions = getUpdateApplicationByUuidMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Get application logs by UUID.
 * @summary Get application logs.
 */
export type getApplicationLogsByUuidResponse200 = {
  data: GetApplicationLogsByUuid200;
  status: 200;
};

export type getApplicationLogsByUuidResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type getApplicationLogsByUuidResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type getApplicationLogsByUuidResponse404 = {
  data: NHttp404Response;
  status: 404;
};

export type getApplicationLogsByUuidResponseSuccess =
  getApplicationLogsByUuidResponse200 & {
    headers: Headers;
  };
export type getApplicationLogsByUuidResponseError = (
  | getApplicationLogsByUuidResponse400
  | getApplicationLogsByUuidResponse401
  | getApplicationLogsByUuidResponse404
) & {
  headers: Headers;
};

export type getApplicationLogsByUuidResponse =
  | getApplicationLogsByUuidResponseSuccess
  | getApplicationLogsByUuidResponseError;

export const getGetApplicationLogsByUuidUrl = (
  uuid: string,
  params?: GetApplicationLogsByUuidParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/coolify/applications/${uuid}/logs?${stringifiedParams}`
    : `/api/coolify/applications/${uuid}/logs`;
};

export const getApplicationLogsByUuid = async (
  uuid: string,
  params?: GetApplicationLogsByUuidParams,
  options?: RequestInit,
): Promise<getApplicationLogsByUuidResponse> => {
  const res = await fetch(getGetApplicationLogsByUuidUrl(uuid, params), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getApplicationLogsByUuidResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as getApplicationLogsByUuidResponse;
};

export const getGetApplicationLogsByUuidQueryKey = (
  uuid?: string,
  params?: GetApplicationLogsByUuidParams,
) => {
  return [
    `/api/coolify/applications/${uuid}/logs`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetApplicationLogsByUuidInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getApplicationLogsByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params?: GetApplicationLogsByUuidParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetApplicationLogsByUuidQueryKey(uuid, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getApplicationLogsByUuid>>
  > = ({ signal }) =>
    getApplicationLogsByUuid(uuid, params, { signal, ...fetchOptions });

  return {
    enabled: !!uuid,
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetApplicationLogsByUuidInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getApplicationLogsByUuid>>
>;
export type GetApplicationLogsByUuidInfiniteQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useGetApplicationLogsByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getApplicationLogsByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params: undefined | GetApplicationLogsByUuidParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
          TError,
          Awaited<ReturnType<typeof getApplicationLogsByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetApplicationLogsByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getApplicationLogsByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params?: GetApplicationLogsByUuidParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
          TError,
          Awaited<ReturnType<typeof getApplicationLogsByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetApplicationLogsByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getApplicationLogsByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params?: GetApplicationLogsByUuidParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get application logs.
 */

export function useGetApplicationLogsByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getApplicationLogsByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params?: GetApplicationLogsByUuidParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetApplicationLogsByUuidInfiniteQueryOptions(
    uuid,
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get application logs.
 */
export const prefetchGetApplicationLogsByUuidInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  queryClient: QueryClient,
  uuid: string,
  params?: GetApplicationLogsByUuidParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetApplicationLogsByUuidInfiniteQueryOptions(
    uuid,
    params,
    options,
  );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const getGetApplicationLogsByUuidQueryOptions = <
  TData = Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params?: GetApplicationLogsByUuidParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetApplicationLogsByUuidQueryKey(uuid, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getApplicationLogsByUuid>>
  > = ({ signal }) =>
    getApplicationLogsByUuid(uuid, params, { signal, ...fetchOptions });

  return {
    enabled: !!uuid,
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetApplicationLogsByUuidQueryResult = NonNullable<
  Awaited<ReturnType<typeof getApplicationLogsByUuid>>
>;
export type GetApplicationLogsByUuidQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useGetApplicationLogsByUuid<
  TData = Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params: undefined | GetApplicationLogsByUuidParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
          TError,
          Awaited<ReturnType<typeof getApplicationLogsByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetApplicationLogsByUuid<
  TData = Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params?: GetApplicationLogsByUuidParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
          TError,
          Awaited<ReturnType<typeof getApplicationLogsByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetApplicationLogsByUuid<
  TData = Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params?: GetApplicationLogsByUuidParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get application logs.
 */

export function useGetApplicationLogsByUuid<
  TData = Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params?: GetApplicationLogsByUuidParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetApplicationLogsByUuidQueryOptions(
    uuid,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get application logs.
 */
export const prefetchGetApplicationLogsByUuidQuery = async <
  TData = Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  queryClient: QueryClient,
  uuid: string,
  params?: GetApplicationLogsByUuidParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetApplicationLogsByUuidQueryOptions(
    uuid,
    params,
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getGetApplicationLogsByUuidSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params?: GetApplicationLogsByUuidParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetApplicationLogsByUuidQueryKey(uuid, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getApplicationLogsByUuid>>
  > = ({ signal }) =>
    getApplicationLogsByUuid(uuid, params, { signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetApplicationLogsByUuidSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getApplicationLogsByUuid>>
>;
export type GetApplicationLogsByUuidSuspenseQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useGetApplicationLogsByUuidSuspense<
  TData = Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params: undefined | GetApplicationLogsByUuidParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetApplicationLogsByUuidSuspense<
  TData = Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params?: GetApplicationLogsByUuidParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetApplicationLogsByUuidSuspense<
  TData = Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params?: GetApplicationLogsByUuidParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get application logs.
 */

export function useGetApplicationLogsByUuidSuspense<
  TData = Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params?: GetApplicationLogsByUuidParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getApplicationLogsByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetApplicationLogsByUuidSuspenseQueryOptions(
    uuid,
    params,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * List all envs by application UUID.
 * @summary List Envs
 */
export type listEnvsByApplicationUuidResponse200 = {
  data: EnvironmentVariableDTO[];
  status: 200;
};

export type listEnvsByApplicationUuidResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type listEnvsByApplicationUuidResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type listEnvsByApplicationUuidResponse404 = {
  data: NHttp404Response;
  status: 404;
};

export type listEnvsByApplicationUuidResponseSuccess =
  listEnvsByApplicationUuidResponse200 & {
    headers: Headers;
  };
export type listEnvsByApplicationUuidResponseError = (
  | listEnvsByApplicationUuidResponse400
  | listEnvsByApplicationUuidResponse401
  | listEnvsByApplicationUuidResponse404
) & {
  headers: Headers;
};

export type listEnvsByApplicationUuidResponse =
  | listEnvsByApplicationUuidResponseSuccess
  | listEnvsByApplicationUuidResponseError;

export const getListEnvsByApplicationUuidUrl = (uuid: string) => {
  return `/api/coolify/applications/${uuid}/envs`;
};

export const listEnvsByApplicationUuid = async (
  uuid: string,
  options?: RequestInit,
): Promise<listEnvsByApplicationUuidResponse> => {
  const res = await fetch(getListEnvsByApplicationUuidUrl(uuid), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: listEnvsByApplicationUuidResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as listEnvsByApplicationUuidResponse;
};

export const getListEnvsByApplicationUuidQueryKey = (uuid?: string) => {
  return [`/api/coolify/applications/${uuid}/envs`] as const;
};

export const getListEnvsByApplicationUuidInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof listEnvsByApplicationUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getListEnvsByApplicationUuidQueryKey(uuid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listEnvsByApplicationUuid>>
  > = ({ signal }) =>
    listEnvsByApplicationUuid(uuid, { signal, ...fetchOptions });

  return {
    enabled: !!uuid,
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListEnvsByApplicationUuidInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof listEnvsByApplicationUuid>>
>;
export type ListEnvsByApplicationUuidInfiniteQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useListEnvsByApplicationUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof listEnvsByApplicationUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
          TError,
          Awaited<ReturnType<typeof listEnvsByApplicationUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListEnvsByApplicationUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof listEnvsByApplicationUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
          TError,
          Awaited<ReturnType<typeof listEnvsByApplicationUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListEnvsByApplicationUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof listEnvsByApplicationUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List Envs
 */

export function useListEnvsByApplicationUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof listEnvsByApplicationUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getListEnvsByApplicationUuidInfiniteQueryOptions(
    uuid,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary List Envs
 */
export const prefetchListEnvsByApplicationUuidInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  queryClient: QueryClient,
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getListEnvsByApplicationUuidInfiniteQueryOptions(
    uuid,
    options,
  );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const getListEnvsByApplicationUuidQueryOptions = <
  TData = Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getListEnvsByApplicationUuidQueryKey(uuid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listEnvsByApplicationUuid>>
  > = ({ signal }) =>
    listEnvsByApplicationUuid(uuid, { signal, ...fetchOptions });

  return {
    enabled: !!uuid,
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListEnvsByApplicationUuidQueryResult = NonNullable<
  Awaited<ReturnType<typeof listEnvsByApplicationUuid>>
>;
export type ListEnvsByApplicationUuidQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useListEnvsByApplicationUuid<
  TData = Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
          TError,
          Awaited<ReturnType<typeof listEnvsByApplicationUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListEnvsByApplicationUuid<
  TData = Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
          TError,
          Awaited<ReturnType<typeof listEnvsByApplicationUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListEnvsByApplicationUuid<
  TData = Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List Envs
 */

export function useListEnvsByApplicationUuid<
  TData = Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getListEnvsByApplicationUuidQueryOptions(uuid, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary List Envs
 */
export const prefetchListEnvsByApplicationUuidQuery = async <
  TData = Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  queryClient: QueryClient,
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getListEnvsByApplicationUuidQueryOptions(uuid, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getListEnvsByApplicationUuidSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getListEnvsByApplicationUuidQueryKey(uuid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listEnvsByApplicationUuid>>
  > = ({ signal }) =>
    listEnvsByApplicationUuid(uuid, { signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListEnvsByApplicationUuidSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof listEnvsByApplicationUuid>>
>;
export type ListEnvsByApplicationUuidSuspenseQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useListEnvsByApplicationUuidSuspense<
  TData = Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListEnvsByApplicationUuidSuspense<
  TData = Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListEnvsByApplicationUuidSuspense<
  TData = Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List Envs
 */

export function useListEnvsByApplicationUuidSuspense<
  TData = Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof listEnvsByApplicationUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getListEnvsByApplicationUuidSuspenseQueryOptions(
    uuid,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Create env by application UUID.
 * @summary Create Env
 */
export type createEnvByApplicationUuidResponse201 = {
  data: CreateEnvByApplicationUuid201;
  status: 201;
};

export type createEnvByApplicationUuidResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type createEnvByApplicationUuidResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type createEnvByApplicationUuidResponse404 = {
  data: NHttp404Response;
  status: 404;
};

export type createEnvByApplicationUuidResponseSuccess =
  createEnvByApplicationUuidResponse201 & {
    headers: Headers;
  };
export type createEnvByApplicationUuidResponseError = (
  | createEnvByApplicationUuidResponse400
  | createEnvByApplicationUuidResponse401
  | createEnvByApplicationUuidResponse404
) & {
  headers: Headers;
};

export type createEnvByApplicationUuidResponse =
  | createEnvByApplicationUuidResponseSuccess
  | createEnvByApplicationUuidResponseError;

export const getCreateEnvByApplicationUuidUrl = (uuid: string) => {
  return `/api/coolify/applications/${uuid}/envs`;
};

export const createEnvByApplicationUuid = async (
  uuid: string,
  createEnvByApplicationUuidBodies: CreateEnvByApplicationUuidBodies,
  options?: RequestInit,
): Promise<createEnvByApplicationUuidResponse> => {
  const res = await fetch(getCreateEnvByApplicationUuidUrl(uuid), {
    ...options,
    body: JSON.stringify(createEnvByApplicationUuidBodies),
    headers: { "Content-Type": "application/json", ...options?.headers },
    method: "POST",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: createEnvByApplicationUuidResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as createEnvByApplicationUuidResponse;
};

export const getCreateEnvByApplicationUuidMutationOptions = <
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createEnvByApplicationUuid>>,
    TError,
    { uuid: string; data: CreateEnvByApplicationUuidBodies },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createEnvByApplicationUuid>>,
  TError,
  { uuid: string; data: CreateEnvByApplicationUuidBodies },
  TContext
> => {
  const mutationKey = ["createEnvByApplicationUuid"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { fetch: undefined, mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createEnvByApplicationUuid>>,
    { uuid: string; data: CreateEnvByApplicationUuidBodies }
  > = (props) => {
    const { uuid, data } = props ?? {};

    return createEnvByApplicationUuid(uuid, data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateEnvByApplicationUuidMutationResult = NonNullable<
  Awaited<ReturnType<typeof createEnvByApplicationUuid>>
>;
export type CreateEnvByApplicationUuidMutationBody =
  CreateEnvByApplicationUuidBodies;
export type CreateEnvByApplicationUuidMutationError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

/**
 * @summary Create Env
 */
export const useCreateEnvByApplicationUuid = <
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createEnvByApplicationUuid>>,
      TError,
      { uuid: string; data: CreateEnvByApplicationUuidBodies },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createEnvByApplicationUuid>>,
  TError,
  { uuid: string; data: CreateEnvByApplicationUuidBodies },
  TContext
> => {
  const mutationOptions = getCreateEnvByApplicationUuidMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Update env by application UUID.
 * @summary Update Env
 */
export type updateEnvByApplicationUuidResponse201 = {
  data: UpdateEnvByApplicationUuid201;
  status: 201;
};

export type updateEnvByApplicationUuidResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type updateEnvByApplicationUuidResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type updateEnvByApplicationUuidResponse404 = {
  data: NHttp404Response;
  status: 404;
};

export type updateEnvByApplicationUuidResponseSuccess =
  updateEnvByApplicationUuidResponse201 & {
    headers: Headers;
  };
export type updateEnvByApplicationUuidResponseError = (
  | updateEnvByApplicationUuidResponse400
  | updateEnvByApplicationUuidResponse401
  | updateEnvByApplicationUuidResponse404
) & {
  headers: Headers;
};

export type updateEnvByApplicationUuidResponse =
  | updateEnvByApplicationUuidResponseSuccess
  | updateEnvByApplicationUuidResponseError;

export const getUpdateEnvByApplicationUuidUrl = (uuid: string) => {
  return `/api/coolify/applications/${uuid}/envs`;
};

export const updateEnvByApplicationUuid = async (
  uuid: string,
  updateEnvByApplicationUuidBodies: UpdateEnvByApplicationUuidBodies,
  options?: RequestInit,
): Promise<updateEnvByApplicationUuidResponse> => {
  const res = await fetch(getUpdateEnvByApplicationUuidUrl(uuid), {
    ...options,
    body: JSON.stringify(updateEnvByApplicationUuidBodies),
    headers: { "Content-Type": "application/json", ...options?.headers },
    method: "PATCH",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: updateEnvByApplicationUuidResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as updateEnvByApplicationUuidResponse;
};

export const getUpdateEnvByApplicationUuidMutationOptions = <
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateEnvByApplicationUuid>>,
    TError,
    { uuid: string; data: UpdateEnvByApplicationUuidBodies },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateEnvByApplicationUuid>>,
  TError,
  { uuid: string; data: UpdateEnvByApplicationUuidBodies },
  TContext
> => {
  const mutationKey = ["updateEnvByApplicationUuid"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { fetch: undefined, mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateEnvByApplicationUuid>>,
    { uuid: string; data: UpdateEnvByApplicationUuidBodies }
  > = (props) => {
    const { uuid, data } = props ?? {};

    return updateEnvByApplicationUuid(uuid, data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateEnvByApplicationUuidMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateEnvByApplicationUuid>>
>;
export type UpdateEnvByApplicationUuidMutationBody =
  UpdateEnvByApplicationUuidBodies;
export type UpdateEnvByApplicationUuidMutationError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

/**
 * @summary Update Env
 */
export const useUpdateEnvByApplicationUuid = <
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateEnvByApplicationUuid>>,
      TError,
      { uuid: string; data: UpdateEnvByApplicationUuidBodies },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateEnvByApplicationUuid>>,
  TError,
  { uuid: string; data: UpdateEnvByApplicationUuidBodies },
  TContext
> => {
  const mutationOptions = getUpdateEnvByApplicationUuidMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Update multiple envs by application UUID.
 * @summary Update Envs (Bulk)
 */
export type updateEnvsByApplicationUuidResponse201 = {
  data: UpdateEnvsByApplicationUuid201;
  status: 201;
};

export type updateEnvsByApplicationUuidResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type updateEnvsByApplicationUuidResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type updateEnvsByApplicationUuidResponse404 = {
  data: NHttp404Response;
  status: 404;
};

export type updateEnvsByApplicationUuidResponseSuccess =
  updateEnvsByApplicationUuidResponse201 & {
    headers: Headers;
  };
export type updateEnvsByApplicationUuidResponseError = (
  | updateEnvsByApplicationUuidResponse400
  | updateEnvsByApplicationUuidResponse401
  | updateEnvsByApplicationUuidResponse404
) & {
  headers: Headers;
};

export type updateEnvsByApplicationUuidResponse =
  | updateEnvsByApplicationUuidResponseSuccess
  | updateEnvsByApplicationUuidResponseError;

export const getUpdateEnvsByApplicationUuidUrl = (uuid: string) => {
  return `/api/coolify/applications/${uuid}/envs/bulk`;
};

export const updateEnvsByApplicationUuid = async (
  uuid: string,
  updateEnvsByApplicationUuidBodies: UpdateEnvsByApplicationUuidBodies,
  options?: RequestInit,
): Promise<updateEnvsByApplicationUuidResponse> => {
  const res = await fetch(getUpdateEnvsByApplicationUuidUrl(uuid), {
    ...options,
    body: JSON.stringify(updateEnvsByApplicationUuidBodies),
    headers: { "Content-Type": "application/json", ...options?.headers },
    method: "PATCH",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: updateEnvsByApplicationUuidResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as updateEnvsByApplicationUuidResponse;
};

export const getUpdateEnvsByApplicationUuidMutationOptions = <
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateEnvsByApplicationUuid>>,
    TError,
    { uuid: string; data: UpdateEnvsByApplicationUuidBodies },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateEnvsByApplicationUuid>>,
  TError,
  { uuid: string; data: UpdateEnvsByApplicationUuidBodies },
  TContext
> => {
  const mutationKey = ["updateEnvsByApplicationUuid"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { fetch: undefined, mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateEnvsByApplicationUuid>>,
    { uuid: string; data: UpdateEnvsByApplicationUuidBodies }
  > = (props) => {
    const { uuid, data } = props ?? {};

    return updateEnvsByApplicationUuid(uuid, data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateEnvsByApplicationUuidMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateEnvsByApplicationUuid>>
>;
export type UpdateEnvsByApplicationUuidMutationBody =
  UpdateEnvsByApplicationUuidBodies;
export type UpdateEnvsByApplicationUuidMutationError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

/**
 * @summary Update Envs (Bulk)
 */
export const useUpdateEnvsByApplicationUuid = <
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateEnvsByApplicationUuid>>,
      TError,
      { uuid: string; data: UpdateEnvsByApplicationUuidBodies },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateEnvsByApplicationUuid>>,
  TError,
  { uuid: string; data: UpdateEnvsByApplicationUuidBodies },
  TContext
> => {
  const mutationOptions =
    getUpdateEnvsByApplicationUuidMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Delete env by UUID.
 * @summary Delete Env
 */
export type deleteEnvByApplicationUuidResponse200 = {
  data: DeleteEnvByApplicationUuid200;
  status: 200;
};

export type deleteEnvByApplicationUuidResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type deleteEnvByApplicationUuidResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type deleteEnvByApplicationUuidResponse404 = {
  data: NHttp404Response;
  status: 404;
};

export type deleteEnvByApplicationUuidResponseSuccess =
  deleteEnvByApplicationUuidResponse200 & {
    headers: Headers;
  };
export type deleteEnvByApplicationUuidResponseError = (
  | deleteEnvByApplicationUuidResponse400
  | deleteEnvByApplicationUuidResponse401
  | deleteEnvByApplicationUuidResponse404
) & {
  headers: Headers;
};

export type deleteEnvByApplicationUuidResponse =
  | deleteEnvByApplicationUuidResponseSuccess
  | deleteEnvByApplicationUuidResponseError;

export const getDeleteEnvByApplicationUuidUrl = (
  uuid: string,
  envUuid: string,
) => {
  return `/api/coolify/applications/${uuid}/envs/${envUuid}`;
};

export const deleteEnvByApplicationUuid = async (
  uuid: string,
  envUuid: string,
  options?: RequestInit,
): Promise<deleteEnvByApplicationUuidResponse> => {
  const res = await fetch(getDeleteEnvByApplicationUuidUrl(uuid, envUuid), {
    ...options,
    method: "DELETE",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: deleteEnvByApplicationUuidResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as deleteEnvByApplicationUuidResponse;
};

export const getDeleteEnvByApplicationUuidMutationOptions = <
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteEnvByApplicationUuid>>,
    TError,
    { uuid: string; envUuid: string },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteEnvByApplicationUuid>>,
  TError,
  { uuid: string; envUuid: string },
  TContext
> => {
  const mutationKey = ["deleteEnvByApplicationUuid"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { fetch: undefined, mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteEnvByApplicationUuid>>,
    { uuid: string; envUuid: string }
  > = (props) => {
    const { uuid, envUuid } = props ?? {};

    return deleteEnvByApplicationUuid(uuid, envUuid, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteEnvByApplicationUuidMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteEnvByApplicationUuid>>
>;

export type DeleteEnvByApplicationUuidMutationError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

/**
 * @summary Delete Env
 */
export const useDeleteEnvByApplicationUuid = <
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteEnvByApplicationUuid>>,
      TError,
      { uuid: string; envUuid: string },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteEnvByApplicationUuid>>,
  TError,
  { uuid: string; envUuid: string },
  TContext
> => {
  const mutationOptions = getDeleteEnvByApplicationUuidMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Start application. `Post` request is also accepted.
 * @summary Start
 */
export type startApplicationByUuidResponse200 = {
  data: StartApplicationByUuid200;
  status: 200;
};

export type startApplicationByUuidResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type startApplicationByUuidResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type startApplicationByUuidResponse404 = {
  data: NHttp404Response;
  status: 404;
};

export type startApplicationByUuidResponseSuccess =
  startApplicationByUuidResponse200 & {
    headers: Headers;
  };
export type startApplicationByUuidResponseError = (
  | startApplicationByUuidResponse400
  | startApplicationByUuidResponse401
  | startApplicationByUuidResponse404
) & {
  headers: Headers;
};

export type startApplicationByUuidResponse =
  | startApplicationByUuidResponseSuccess
  | startApplicationByUuidResponseError;

export const getStartApplicationByUuidUrl = (
  uuid: string,
  params?: StartApplicationByUuidParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/coolify/applications/${uuid}/start?${stringifiedParams}`
    : `/api/coolify/applications/${uuid}/start`;
};

export const startApplicationByUuid = async (
  uuid: string,
  params?: StartApplicationByUuidParams,
  options?: RequestInit,
): Promise<startApplicationByUuidResponse> => {
  const res = await fetch(getStartApplicationByUuidUrl(uuid, params), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: startApplicationByUuidResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as startApplicationByUuidResponse;
};

export const getStartApplicationByUuidQueryKey = (
  uuid?: string,
  params?: StartApplicationByUuidParams,
) => {
  return [
    `/api/coolify/applications/${uuid}/start`,
    ...(params ? [params] : []),
  ] as const;
};

export const getStartApplicationByUuidInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof startApplicationByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params?: StartApplicationByUuidParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof startApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStartApplicationByUuidQueryKey(uuid, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof startApplicationByUuid>>
  > = ({ signal }) =>
    startApplicationByUuid(uuid, params, { signal, ...fetchOptions });

  return {
    enabled: !!uuid,
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof startApplicationByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StartApplicationByUuidInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof startApplicationByUuid>>
>;
export type StartApplicationByUuidInfiniteQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useStartApplicationByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof startApplicationByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params: undefined | StartApplicationByUuidParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof startApplicationByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof startApplicationByUuid>>,
          TError,
          Awaited<ReturnType<typeof startApplicationByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStartApplicationByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof startApplicationByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params?: StartApplicationByUuidParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof startApplicationByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof startApplicationByUuid>>,
          TError,
          Awaited<ReturnType<typeof startApplicationByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStartApplicationByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof startApplicationByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params?: StartApplicationByUuidParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof startApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Start
 */

export function useStartApplicationByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof startApplicationByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params?: StartApplicationByUuidParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof startApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getStartApplicationByUuidInfiniteQueryOptions(
    uuid,
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Start
 */
export const prefetchStartApplicationByUuidInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof startApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  queryClient: QueryClient,
  uuid: string,
  params?: StartApplicationByUuidParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof startApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getStartApplicationByUuidInfiniteQueryOptions(
    uuid,
    params,
    options,
  );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const getStartApplicationByUuidQueryOptions = <
  TData = Awaited<ReturnType<typeof startApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params?: StartApplicationByUuidParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStartApplicationByUuidQueryKey(uuid, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof startApplicationByUuid>>
  > = ({ signal }) =>
    startApplicationByUuid(uuid, params, { signal, ...fetchOptions });

  return {
    enabled: !!uuid,
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof startApplicationByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StartApplicationByUuidQueryResult = NonNullable<
  Awaited<ReturnType<typeof startApplicationByUuid>>
>;
export type StartApplicationByUuidQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useStartApplicationByUuid<
  TData = Awaited<ReturnType<typeof startApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params: undefined | StartApplicationByUuidParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startApplicationByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof startApplicationByUuid>>,
          TError,
          Awaited<ReturnType<typeof startApplicationByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStartApplicationByUuid<
  TData = Awaited<ReturnType<typeof startApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params?: StartApplicationByUuidParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startApplicationByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof startApplicationByUuid>>,
          TError,
          Awaited<ReturnType<typeof startApplicationByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStartApplicationByUuid<
  TData = Awaited<ReturnType<typeof startApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params?: StartApplicationByUuidParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Start
 */

export function useStartApplicationByUuid<
  TData = Awaited<ReturnType<typeof startApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params?: StartApplicationByUuidParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getStartApplicationByUuidQueryOptions(
    uuid,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Start
 */
export const prefetchStartApplicationByUuidQuery = async <
  TData = Awaited<ReturnType<typeof startApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  queryClient: QueryClient,
  uuid: string,
  params?: StartApplicationByUuidParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getStartApplicationByUuidQueryOptions(
    uuid,
    params,
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getStartApplicationByUuidSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof startApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params?: StartApplicationByUuidParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof startApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStartApplicationByUuidQueryKey(uuid, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof startApplicationByUuid>>
  > = ({ signal }) =>
    startApplicationByUuid(uuid, params, { signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof startApplicationByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StartApplicationByUuidSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof startApplicationByUuid>>
>;
export type StartApplicationByUuidSuspenseQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useStartApplicationByUuidSuspense<
  TData = Awaited<ReturnType<typeof startApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params: undefined | StartApplicationByUuidParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof startApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStartApplicationByUuidSuspense<
  TData = Awaited<ReturnType<typeof startApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params?: StartApplicationByUuidParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof startApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStartApplicationByUuidSuspense<
  TData = Awaited<ReturnType<typeof startApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params?: StartApplicationByUuidParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof startApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Start
 */

export function useStartApplicationByUuidSuspense<
  TData = Awaited<ReturnType<typeof startApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  params?: StartApplicationByUuidParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof startApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getStartApplicationByUuidSuspenseQueryOptions(
    uuid,
    params,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Stop application. `Post` request is also accepted.
 * @summary Stop
 */
export type stopApplicationByUuidResponse200 = {
  data: StopApplicationByUuid200;
  status: 200;
};

export type stopApplicationByUuidResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type stopApplicationByUuidResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type stopApplicationByUuidResponse404 = {
  data: NHttp404Response;
  status: 404;
};

export type stopApplicationByUuidResponseSuccess =
  stopApplicationByUuidResponse200 & {
    headers: Headers;
  };
export type stopApplicationByUuidResponseError = (
  | stopApplicationByUuidResponse400
  | stopApplicationByUuidResponse401
  | stopApplicationByUuidResponse404
) & {
  headers: Headers;
};

export type stopApplicationByUuidResponse =
  | stopApplicationByUuidResponseSuccess
  | stopApplicationByUuidResponseError;

export const getStopApplicationByUuidUrl = (uuid: string) => {
  return `/api/coolify/applications/${uuid}/stop`;
};

export const stopApplicationByUuid = async (
  uuid: string,
  options?: RequestInit,
): Promise<stopApplicationByUuidResponse> => {
  const res = await fetch(getStopApplicationByUuidUrl(uuid), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: stopApplicationByUuidResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as stopApplicationByUuidResponse;
};

export const getStopApplicationByUuidQueryKey = (uuid?: string) => {
  return [`/api/coolify/applications/${uuid}/stop`] as const;
};

export const getStopApplicationByUuidInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof stopApplicationByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof stopApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStopApplicationByUuidQueryKey(uuid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof stopApplicationByUuid>>
  > = ({ signal }) => stopApplicationByUuid(uuid, { signal, ...fetchOptions });

  return {
    enabled: !!uuid,
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof stopApplicationByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StopApplicationByUuidInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof stopApplicationByUuid>>
>;
export type StopApplicationByUuidInfiniteQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useStopApplicationByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof stopApplicationByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof stopApplicationByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stopApplicationByUuid>>,
          TError,
          Awaited<ReturnType<typeof stopApplicationByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStopApplicationByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof stopApplicationByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof stopApplicationByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stopApplicationByUuid>>,
          TError,
          Awaited<ReturnType<typeof stopApplicationByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStopApplicationByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof stopApplicationByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof stopApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Stop
 */

export function useStopApplicationByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof stopApplicationByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof stopApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getStopApplicationByUuidInfiniteQueryOptions(
    uuid,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Stop
 */
export const prefetchStopApplicationByUuidInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof stopApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  queryClient: QueryClient,
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof stopApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getStopApplicationByUuidInfiniteQueryOptions(
    uuid,
    options,
  );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const getStopApplicationByUuidQueryOptions = <
  TData = Awaited<ReturnType<typeof stopApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof stopApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStopApplicationByUuidQueryKey(uuid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof stopApplicationByUuid>>
  > = ({ signal }) => stopApplicationByUuid(uuid, { signal, ...fetchOptions });

  return {
    enabled: !!uuid,
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof stopApplicationByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StopApplicationByUuidQueryResult = NonNullable<
  Awaited<ReturnType<typeof stopApplicationByUuid>>
>;
export type StopApplicationByUuidQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useStopApplicationByUuid<
  TData = Awaited<ReturnType<typeof stopApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof stopApplicationByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stopApplicationByUuid>>,
          TError,
          Awaited<ReturnType<typeof stopApplicationByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStopApplicationByUuid<
  TData = Awaited<ReturnType<typeof stopApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof stopApplicationByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stopApplicationByUuid>>,
          TError,
          Awaited<ReturnType<typeof stopApplicationByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStopApplicationByUuid<
  TData = Awaited<ReturnType<typeof stopApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof stopApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Stop
 */

export function useStopApplicationByUuid<
  TData = Awaited<ReturnType<typeof stopApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof stopApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getStopApplicationByUuidQueryOptions(uuid, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Stop
 */
export const prefetchStopApplicationByUuidQuery = async <
  TData = Awaited<ReturnType<typeof stopApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  queryClient: QueryClient,
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof stopApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getStopApplicationByUuidQueryOptions(uuid, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getStopApplicationByUuidSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof stopApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof stopApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStopApplicationByUuidQueryKey(uuid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof stopApplicationByUuid>>
  > = ({ signal }) => stopApplicationByUuid(uuid, { signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof stopApplicationByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StopApplicationByUuidSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof stopApplicationByUuid>>
>;
export type StopApplicationByUuidSuspenseQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useStopApplicationByUuidSuspense<
  TData = Awaited<ReturnType<typeof stopApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof stopApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStopApplicationByUuidSuspense<
  TData = Awaited<ReturnType<typeof stopApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof stopApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStopApplicationByUuidSuspense<
  TData = Awaited<ReturnType<typeof stopApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof stopApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Stop
 */

export function useStopApplicationByUuidSuspense<
  TData = Awaited<ReturnType<typeof stopApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof stopApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getStopApplicationByUuidSuspenseQueryOptions(
    uuid,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Restart application. `Post` request is also accepted.
 * @summary Restart
 */
export type restartApplicationByUuidResponse200 = {
  data: RestartApplicationByUuid200;
  status: 200;
};

export type restartApplicationByUuidResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type restartApplicationByUuidResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type restartApplicationByUuidResponse404 = {
  data: NHttp404Response;
  status: 404;
};

export type restartApplicationByUuidResponseSuccess =
  restartApplicationByUuidResponse200 & {
    headers: Headers;
  };
export type restartApplicationByUuidResponseError = (
  | restartApplicationByUuidResponse400
  | restartApplicationByUuidResponse401
  | restartApplicationByUuidResponse404
) & {
  headers: Headers;
};

export type restartApplicationByUuidResponse =
  | restartApplicationByUuidResponseSuccess
  | restartApplicationByUuidResponseError;

export const getRestartApplicationByUuidUrl = (uuid: string) => {
  return `/api/coolify/applications/${uuid}/restart`;
};

export const restartApplicationByUuid = async (
  uuid: string,
  options?: RequestInit,
): Promise<restartApplicationByUuidResponse> => {
  const res = await fetch(getRestartApplicationByUuidUrl(uuid), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: restartApplicationByUuidResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as restartApplicationByUuidResponse;
};

export const getRestartApplicationByUuidQueryKey = (uuid?: string) => {
  return [`/api/coolify/applications/${uuid}/restart`] as const;
};

export const getRestartApplicationByUuidInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof restartApplicationByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof restartApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRestartApplicationByUuidQueryKey(uuid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof restartApplicationByUuid>>
  > = ({ signal }) =>
    restartApplicationByUuid(uuid, { signal, ...fetchOptions });

  return {
    enabled: !!uuid,
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof restartApplicationByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RestartApplicationByUuidInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof restartApplicationByUuid>>
>;
export type RestartApplicationByUuidInfiniteQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useRestartApplicationByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof restartApplicationByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof restartApplicationByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof restartApplicationByUuid>>,
          TError,
          Awaited<ReturnType<typeof restartApplicationByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRestartApplicationByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof restartApplicationByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof restartApplicationByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof restartApplicationByUuid>>,
          TError,
          Awaited<ReturnType<typeof restartApplicationByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRestartApplicationByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof restartApplicationByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof restartApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Restart
 */

export function useRestartApplicationByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof restartApplicationByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof restartApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRestartApplicationByUuidInfiniteQueryOptions(
    uuid,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Restart
 */
export const prefetchRestartApplicationByUuidInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof restartApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  queryClient: QueryClient,
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof restartApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getRestartApplicationByUuidInfiniteQueryOptions(
    uuid,
    options,
  );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const getRestartApplicationByUuidQueryOptions = <
  TData = Awaited<ReturnType<typeof restartApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof restartApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRestartApplicationByUuidQueryKey(uuid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof restartApplicationByUuid>>
  > = ({ signal }) =>
    restartApplicationByUuid(uuid, { signal, ...fetchOptions });

  return {
    enabled: !!uuid,
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof restartApplicationByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RestartApplicationByUuidQueryResult = NonNullable<
  Awaited<ReturnType<typeof restartApplicationByUuid>>
>;
export type RestartApplicationByUuidQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useRestartApplicationByUuid<
  TData = Awaited<ReturnType<typeof restartApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof restartApplicationByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof restartApplicationByUuid>>,
          TError,
          Awaited<ReturnType<typeof restartApplicationByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRestartApplicationByUuid<
  TData = Awaited<ReturnType<typeof restartApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof restartApplicationByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof restartApplicationByUuid>>,
          TError,
          Awaited<ReturnType<typeof restartApplicationByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRestartApplicationByUuid<
  TData = Awaited<ReturnType<typeof restartApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof restartApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Restart
 */

export function useRestartApplicationByUuid<
  TData = Awaited<ReturnType<typeof restartApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof restartApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRestartApplicationByUuidQueryOptions(uuid, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Restart
 */
export const prefetchRestartApplicationByUuidQuery = async <
  TData = Awaited<ReturnType<typeof restartApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  queryClient: QueryClient,
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof restartApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getRestartApplicationByUuidQueryOptions(uuid, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getRestartApplicationByUuidSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof restartApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof restartApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRestartApplicationByUuidQueryKey(uuid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof restartApplicationByUuid>>
  > = ({ signal }) =>
    restartApplicationByUuid(uuid, { signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof restartApplicationByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RestartApplicationByUuidSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof restartApplicationByUuid>>
>;
export type RestartApplicationByUuidSuspenseQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useRestartApplicationByUuidSuspense<
  TData = Awaited<ReturnType<typeof restartApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof restartApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRestartApplicationByUuidSuspense<
  TData = Awaited<ReturnType<typeof restartApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof restartApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRestartApplicationByUuidSuspense<
  TData = Awaited<ReturnType<typeof restartApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof restartApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Restart
 */

export function useRestartApplicationByUuidSuspense<
  TData = Awaited<ReturnType<typeof restartApplicationByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof restartApplicationByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRestartApplicationByUuidSuspenseQueryOptions(
    uuid,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
