/**
 * Generated by orval v7.12.2 üç∫
 * Do not edit manually.
 * Coolify
 * OpenAPI spec version: 0.1
 */

import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import {
  useInfiniteQuery,
  useQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";

import type {
  DisableApi200,
  DisableApi403,
  EnableApi200,
  EnableApi403,
  NHttp400Response,
  NHttp401Response,
} from ".././model";

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

/**
 * Get Coolify version.
 * @summary Version
 */
export type versionResponse200 = {
  data: string;
  status: 200;
};

export type versionResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type versionResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type versionResponseSuccess = versionResponse200 & {
  headers: Headers;
};
export type versionResponseError = (versionResponse400 | versionResponse401) & {
  headers: Headers;
};

export type versionResponse = versionResponseSuccess | versionResponseError;

export const getVersionUrl = () => {
  return `/api/coolify/version`;
};

export const version = async (
  options?: RequestInit,
): Promise<versionResponse> => {
  const res = await fetch(getVersionUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: versionResponse["data"] = body ? JSON.parse(body) : {};
  return { data, headers: res.headers, status: res.status } as versionResponse;
};

export const getVersionQueryKey = () => {
  return [`/api/coolify/version`] as const;
};

export const getVersionInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof version>>>,
  TError = NHttp400Response | NHttp401Response,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getVersionQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof version>>> = ({
    signal,
  }) => version({ signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof version>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VersionInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof version>>
>;
export type VersionInfiniteQueryError = NHttp400Response | NHttp401Response;

export function useVersionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof version>>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof version>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof version>>,
          TError,
          Awaited<ReturnType<typeof version>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof version>>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof version>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof version>>,
          TError,
          Awaited<ReturnType<typeof version>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof version>>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof version>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Version
 */

export function useVersionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof version>>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof version>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getVersionInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Version
 */
export const prefetchVersionInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof version>>,
  TError = NHttp400Response | NHttp401Response,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof version>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getVersionInfiniteQueryOptions(options);

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const getVersionQueryOptions = <
  TData = Awaited<ReturnType<typeof version>>,
  TError = NHttp400Response | NHttp401Response,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getVersionQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof version>>> = ({
    signal,
  }) => version({ signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type VersionQueryResult = NonNullable<
  Awaited<ReturnType<typeof version>>
>;
export type VersionQueryError = NHttp400Response | NHttp401Response;

export function useVersion<
  TData = Awaited<ReturnType<typeof version>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof version>>,
          TError,
          Awaited<ReturnType<typeof version>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersion<
  TData = Awaited<ReturnType<typeof version>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof version>>,
          TError,
          Awaited<ReturnType<typeof version>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersion<
  TData = Awaited<ReturnType<typeof version>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Version
 */

export function useVersion<
  TData = Awaited<ReturnType<typeof version>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getVersionQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Version
 */
export const prefetchVersionQuery = async <
  TData = Awaited<ReturnType<typeof version>>,
  TError = NHttp400Response | NHttp401Response,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getVersionQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getVersionSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof version>>,
  TError = NHttp400Response | NHttp401Response,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getVersionQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof version>>> = ({
    signal,
  }) => version({ signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof version>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VersionSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof version>>
>;
export type VersionSuspenseQueryError = NHttp400Response | NHttp401Response;

export function useVersionSuspense<
  TData = Awaited<ReturnType<typeof version>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof version>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionSuspense<
  TData = Awaited<ReturnType<typeof version>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof version>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionSuspense<
  TData = Awaited<ReturnType<typeof version>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof version>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Version
 */

export function useVersionSuspense<
  TData = Awaited<ReturnType<typeof version>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof version>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getVersionSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Enable API (only with root permissions).
 * @summary Enable API
 */
export type enableApiResponse200 = {
  data: EnableApi200;
  status: 200;
};

export type enableApiResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type enableApiResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type enableApiResponse403 = {
  data: EnableApi403;
  status: 403;
};

export type enableApiResponseSuccess = enableApiResponse200 & {
  headers: Headers;
};
export type enableApiResponseError = (
  | enableApiResponse400
  | enableApiResponse401
  | enableApiResponse403
) & {
  headers: Headers;
};

export type enableApiResponse =
  | enableApiResponseSuccess
  | enableApiResponseError;

export const getEnableApiUrl = () => {
  return `/api/coolify/enable`;
};

export const enableApi = async (
  options?: RequestInit,
): Promise<enableApiResponse> => {
  const res = await fetch(getEnableApiUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: enableApiResponse["data"] = body ? JSON.parse(body) : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as enableApiResponse;
};

export const getEnableApiQueryKey = () => {
  return [`/api/coolify/enable`] as const;
};

export const getEnableApiInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof enableApi>>>,
  TError = NHttp400Response | NHttp401Response | EnableApi403,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof enableApi>>,
      TError,
      TData
    >
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getEnableApiQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof enableApi>>> = ({
    signal,
  }) => enableApi({ signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof enableApi>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EnableApiInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof enableApi>>
>;
export type EnableApiInfiniteQueryError =
  | NHttp400Response
  | NHttp401Response
  | EnableApi403;

export function useEnableApiInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof enableApi>>>,
  TError = NHttp400Response | NHttp401Response | EnableApi403,
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof enableApi>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof enableApi>>,
          TError,
          Awaited<ReturnType<typeof enableApi>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEnableApiInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof enableApi>>>,
  TError = NHttp400Response | NHttp401Response | EnableApi403,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof enableApi>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof enableApi>>,
          TError,
          Awaited<ReturnType<typeof enableApi>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEnableApiInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof enableApi>>>,
  TError = NHttp400Response | NHttp401Response | EnableApi403,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof enableApi>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Enable API
 */

export function useEnableApiInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof enableApi>>>,
  TError = NHttp400Response | NHttp401Response | EnableApi403,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof enableApi>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEnableApiInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Enable API
 */
export const prefetchEnableApiInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof enableApi>>,
  TError = NHttp400Response | NHttp401Response | EnableApi403,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof enableApi>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getEnableApiInfiniteQueryOptions(options);

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const getEnableApiQueryOptions = <
  TData = Awaited<ReturnType<typeof enableApi>>,
  TError = NHttp400Response | NHttp401Response | EnableApi403,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof enableApi>>, TError, TData>
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getEnableApiQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof enableApi>>> = ({
    signal,
  }) => enableApi({ signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof enableApi>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type EnableApiQueryResult = NonNullable<
  Awaited<ReturnType<typeof enableApi>>
>;
export type EnableApiQueryError =
  | NHttp400Response
  | NHttp401Response
  | EnableApi403;

export function useEnableApi<
  TData = Awaited<ReturnType<typeof enableApi>>,
  TError = NHttp400Response | NHttp401Response | EnableApi403,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof enableApi>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof enableApi>>,
          TError,
          Awaited<ReturnType<typeof enableApi>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEnableApi<
  TData = Awaited<ReturnType<typeof enableApi>>,
  TError = NHttp400Response | NHttp401Response | EnableApi403,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof enableApi>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof enableApi>>,
          TError,
          Awaited<ReturnType<typeof enableApi>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEnableApi<
  TData = Awaited<ReturnType<typeof enableApi>>,
  TError = NHttp400Response | NHttp401Response | EnableApi403,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof enableApi>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Enable API
 */

export function useEnableApi<
  TData = Awaited<ReturnType<typeof enableApi>>,
  TError = NHttp400Response | NHttp401Response | EnableApi403,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof enableApi>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEnableApiQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Enable API
 */
export const prefetchEnableApiQuery = async <
  TData = Awaited<ReturnType<typeof enableApi>>,
  TError = NHttp400Response | NHttp401Response | EnableApi403,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof enableApi>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getEnableApiQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getEnableApiSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof enableApi>>,
  TError = NHttp400Response | NHttp401Response | EnableApi403,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof enableApi>>,
      TError,
      TData
    >
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getEnableApiQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof enableApi>>> = ({
    signal,
  }) => enableApi({ signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof enableApi>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EnableApiSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof enableApi>>
>;
export type EnableApiSuspenseQueryError =
  | NHttp400Response
  | NHttp401Response
  | EnableApi403;

export function useEnableApiSuspense<
  TData = Awaited<ReturnType<typeof enableApi>>,
  TError = NHttp400Response | NHttp401Response | EnableApi403,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof enableApi>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEnableApiSuspense<
  TData = Awaited<ReturnType<typeof enableApi>>,
  TError = NHttp400Response | NHttp401Response | EnableApi403,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof enableApi>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEnableApiSuspense<
  TData = Awaited<ReturnType<typeof enableApi>>,
  TError = NHttp400Response | NHttp401Response | EnableApi403,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof enableApi>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Enable API
 */

export function useEnableApiSuspense<
  TData = Awaited<ReturnType<typeof enableApi>>,
  TError = NHttp400Response | NHttp401Response | EnableApi403,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof enableApi>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEnableApiSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Disable API (only with root permissions).
 * @summary Disable API
 */
export type disableApiResponse200 = {
  data: DisableApi200;
  status: 200;
};

export type disableApiResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type disableApiResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type disableApiResponse403 = {
  data: DisableApi403;
  status: 403;
};

export type disableApiResponseSuccess = disableApiResponse200 & {
  headers: Headers;
};
export type disableApiResponseError = (
  | disableApiResponse400
  | disableApiResponse401
  | disableApiResponse403
) & {
  headers: Headers;
};

export type disableApiResponse =
  | disableApiResponseSuccess
  | disableApiResponseError;

export const getDisableApiUrl = () => {
  return `/api/coolify/disable`;
};

export const disableApi = async (
  options?: RequestInit,
): Promise<disableApiResponse> => {
  const res = await fetch(getDisableApiUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: disableApiResponse["data"] = body ? JSON.parse(body) : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as disableApiResponse;
};

export const getDisableApiQueryKey = () => {
  return [`/api/coolify/disable`] as const;
};

export const getDisableApiInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof disableApi>>>,
  TError = NHttp400Response | NHttp401Response | DisableApi403,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof disableApi>>,
      TError,
      TData
    >
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getDisableApiQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof disableApi>>> = ({
    signal,
  }) => disableApi({ signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof disableApi>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DisableApiInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof disableApi>>
>;
export type DisableApiInfiniteQueryError =
  | NHttp400Response
  | NHttp401Response
  | DisableApi403;

export function useDisableApiInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof disableApi>>>,
  TError = NHttp400Response | NHttp401Response | DisableApi403,
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof disableApi>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof disableApi>>,
          TError,
          Awaited<ReturnType<typeof disableApi>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDisableApiInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof disableApi>>>,
  TError = NHttp400Response | NHttp401Response | DisableApi403,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof disableApi>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof disableApi>>,
          TError,
          Awaited<ReturnType<typeof disableApi>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDisableApiInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof disableApi>>>,
  TError = NHttp400Response | NHttp401Response | DisableApi403,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof disableApi>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Disable API
 */

export function useDisableApiInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof disableApi>>>,
  TError = NHttp400Response | NHttp401Response | DisableApi403,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof disableApi>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getDisableApiInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Disable API
 */
export const prefetchDisableApiInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof disableApi>>,
  TError = NHttp400Response | NHttp401Response | DisableApi403,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof disableApi>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getDisableApiInfiniteQueryOptions(options);

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const getDisableApiQueryOptions = <
  TData = Awaited<ReturnType<typeof disableApi>>,
  TError = NHttp400Response | NHttp401Response | DisableApi403,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof disableApi>>, TError, TData>
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getDisableApiQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof disableApi>>> = ({
    signal,
  }) => disableApi({ signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof disableApi>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DisableApiQueryResult = NonNullable<
  Awaited<ReturnType<typeof disableApi>>
>;
export type DisableApiQueryError =
  | NHttp400Response
  | NHttp401Response
  | DisableApi403;

export function useDisableApi<
  TData = Awaited<ReturnType<typeof disableApi>>,
  TError = NHttp400Response | NHttp401Response | DisableApi403,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof disableApi>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof disableApi>>,
          TError,
          Awaited<ReturnType<typeof disableApi>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDisableApi<
  TData = Awaited<ReturnType<typeof disableApi>>,
  TError = NHttp400Response | NHttp401Response | DisableApi403,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof disableApi>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof disableApi>>,
          TError,
          Awaited<ReturnType<typeof disableApi>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDisableApi<
  TData = Awaited<ReturnType<typeof disableApi>>,
  TError = NHttp400Response | NHttp401Response | DisableApi403,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof disableApi>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Disable API
 */

export function useDisableApi<
  TData = Awaited<ReturnType<typeof disableApi>>,
  TError = NHttp400Response | NHttp401Response | DisableApi403,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof disableApi>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getDisableApiQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Disable API
 */
export const prefetchDisableApiQuery = async <
  TData = Awaited<ReturnType<typeof disableApi>>,
  TError = NHttp400Response | NHttp401Response | DisableApi403,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof disableApi>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getDisableApiQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getDisableApiSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof disableApi>>,
  TError = NHttp400Response | NHttp401Response | DisableApi403,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof disableApi>>,
      TError,
      TData
    >
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getDisableApiQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof disableApi>>> = ({
    signal,
  }) => disableApi({ signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof disableApi>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DisableApiSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof disableApi>>
>;
export type DisableApiSuspenseQueryError =
  | NHttp400Response
  | NHttp401Response
  | DisableApi403;

export function useDisableApiSuspense<
  TData = Awaited<ReturnType<typeof disableApi>>,
  TError = NHttp400Response | NHttp401Response | DisableApi403,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof disableApi>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDisableApiSuspense<
  TData = Awaited<ReturnType<typeof disableApi>>,
  TError = NHttp400Response | NHttp401Response | DisableApi403,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof disableApi>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDisableApiSuspense<
  TData = Awaited<ReturnType<typeof disableApi>>,
  TError = NHttp400Response | NHttp401Response | DisableApi403,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof disableApi>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Disable API
 */

export function useDisableApiSuspense<
  TData = Awaited<ReturnType<typeof disableApi>>,
  TError = NHttp400Response | NHttp401Response | DisableApi403,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof disableApi>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getDisableApiSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Healthcheck endpoint.
 * @summary Healthcheck
 */
export type healthcheckResponse200 = {
  data: string;
  status: 200;
};

export type healthcheckResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type healthcheckResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type healthcheckResponseSuccess = healthcheckResponse200 & {
  headers: Headers;
};
export type healthcheckResponseError = (
  | healthcheckResponse400
  | healthcheckResponse401
) & {
  headers: Headers;
};

export type healthcheckResponse =
  | healthcheckResponseSuccess
  | healthcheckResponseError;

export const getHealthcheckUrl = () => {
  return `/api/coolify/health`;
};

export const healthcheck = async (
  options?: RequestInit,
): Promise<healthcheckResponse> => {
  const res = await fetch(getHealthcheckUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: healthcheckResponse["data"] = body ? JSON.parse(body) : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as healthcheckResponse;
};

export const getHealthcheckQueryKey = () => {
  return [`/api/coolify/health`] as const;
};

export const getHealthcheckInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof healthcheck>>>,
  TError = NHttp400Response | NHttp401Response,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof healthcheck>>,
      TError,
      TData
    >
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHealthcheckQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthcheck>>> = ({
    signal,
  }) => healthcheck({ signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof healthcheck>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HealthcheckInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthcheck>>
>;
export type HealthcheckInfiniteQueryError = NHttp400Response | NHttp401Response;

export function useHealthcheckInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof healthcheck>>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof healthcheck>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthcheck>>,
          TError,
          Awaited<ReturnType<typeof healthcheck>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthcheckInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof healthcheck>>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof healthcheck>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthcheck>>,
          TError,
          Awaited<ReturnType<typeof healthcheck>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthcheckInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof healthcheck>>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof healthcheck>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Healthcheck
 */

export function useHealthcheckInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof healthcheck>>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof healthcheck>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getHealthcheckInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Healthcheck
 */
export const prefetchHealthcheckInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof healthcheck>>,
  TError = NHttp400Response | NHttp401Response,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof healthcheck>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getHealthcheckInfiniteQueryOptions(options);

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const getHealthcheckQueryOptions = <
  TData = Awaited<ReturnType<typeof healthcheck>>,
  TError = NHttp400Response | NHttp401Response,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthcheck>>, TError, TData>
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHealthcheckQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthcheck>>> = ({
    signal,
  }) => healthcheck({ signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof healthcheck>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HealthcheckQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthcheck>>
>;
export type HealthcheckQueryError = NHttp400Response | NHttp401Response;

export function useHealthcheck<
  TData = Awaited<ReturnType<typeof healthcheck>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthcheck>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthcheck>>,
          TError,
          Awaited<ReturnType<typeof healthcheck>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthcheck<
  TData = Awaited<ReturnType<typeof healthcheck>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthcheck>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthcheck>>,
          TError,
          Awaited<ReturnType<typeof healthcheck>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthcheck<
  TData = Awaited<ReturnType<typeof healthcheck>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthcheck>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Healthcheck
 */

export function useHealthcheck<
  TData = Awaited<ReturnType<typeof healthcheck>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthcheck>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getHealthcheckQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Healthcheck
 */
export const prefetchHealthcheckQuery = async <
  TData = Awaited<ReturnType<typeof healthcheck>>,
  TError = NHttp400Response | NHttp401Response,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthcheck>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getHealthcheckQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getHealthcheckSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof healthcheck>>,
  TError = NHttp400Response | NHttp401Response,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof healthcheck>>,
      TError,
      TData
    >
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHealthcheckQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthcheck>>> = ({
    signal,
  }) => healthcheck({ signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof healthcheck>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HealthcheckSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthcheck>>
>;
export type HealthcheckSuspenseQueryError = NHttp400Response | NHttp401Response;

export function useHealthcheckSuspense<
  TData = Awaited<ReturnType<typeof healthcheck>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof healthcheck>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthcheckSuspense<
  TData = Awaited<ReturnType<typeof healthcheck>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof healthcheck>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthcheckSuspense<
  TData = Awaited<ReturnType<typeof healthcheck>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof healthcheck>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Healthcheck
 */

export function useHealthcheckSuspense<
  TData = Awaited<ReturnType<typeof healthcheck>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof healthcheck>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getHealthcheckSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
