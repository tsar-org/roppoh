/**
 * Generated by orval v7.12.2 üç∫
 * Do not edit manually.
 * Coolify
 * OpenAPI spec version: 0.1
 */

import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";
import { useQuery } from "@tanstack/react-query";

import type {
  DisableApi200,
  DisableApi403,
  EnableApi200,
  EnableApi403,
  NHttp400Response,
  NHttp401Response,
} from ".././model";

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

/**
 * Get Coolify version.
 * @summary Version
 */
export type versionResponse200 = {
  data: string;
  status: 200;
};

export type versionResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type versionResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type versionResponseSuccess = versionResponse200 & {
  headers: Headers;
};
export type versionResponseError = (versionResponse400 | versionResponse401) & {
  headers: Headers;
};

export type versionResponse = versionResponseSuccess | versionResponseError;

export const getVersionUrl = () => {
  return `https://coolify.tsar-bmb.org/version`;
};

export const version = async (
  options?: RequestInit,
): Promise<versionResponse> => {
  const res = await fetch(getVersionUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: versionResponse["data"] = body ? JSON.parse(body) : {};
  return { data, headers: res.headers, status: res.status } as versionResponse;
};

export const getVersionQueryKey = () => {
  return [`https://coolify.tsar-bmb.org/version`] as const;
};

export const getVersionQueryOptions = <
  TData = Awaited<ReturnType<typeof version>>,
  TError = NHttp400Response | NHttp401Response,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getVersionQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof version>>> = ({
    signal,
  }) => version({ signal, ...fetchOptions });

  return { queryFn, queryKey, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof version>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VersionQueryResult = NonNullable<
  Awaited<ReturnType<typeof version>>
>;
export type VersionQueryError = NHttp400Response | NHttp401Response;

export function useVersion<
  TData = Awaited<ReturnType<typeof version>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof version>>,
          TError,
          Awaited<ReturnType<typeof version>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersion<
  TData = Awaited<ReturnType<typeof version>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof version>>,
          TError,
          Awaited<ReturnType<typeof version>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersion<
  TData = Awaited<ReturnType<typeof version>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Version
 */

export function useVersion<
  TData = Awaited<ReturnType<typeof version>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getVersionQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Enable API (only with root permissions).
 * @summary Enable API
 */
export type enableApiResponse200 = {
  data: EnableApi200;
  status: 200;
};

export type enableApiResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type enableApiResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type enableApiResponse403 = {
  data: EnableApi403;
  status: 403;
};

export type enableApiResponseSuccess = enableApiResponse200 & {
  headers: Headers;
};
export type enableApiResponseError = (
  | enableApiResponse400
  | enableApiResponse401
  | enableApiResponse403
) & {
  headers: Headers;
};

export type enableApiResponse =
  | enableApiResponseSuccess
  | enableApiResponseError;

export const getEnableApiUrl = () => {
  return `https://coolify.tsar-bmb.org/enable`;
};

export const enableApi = async (
  options?: RequestInit,
): Promise<enableApiResponse> => {
  const res = await fetch(getEnableApiUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: enableApiResponse["data"] = body ? JSON.parse(body) : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as enableApiResponse;
};

export const getEnableApiQueryKey = () => {
  return [`https://coolify.tsar-bmb.org/enable`] as const;
};

export const getEnableApiQueryOptions = <
  TData = Awaited<ReturnType<typeof enableApi>>,
  TError = NHttp400Response | NHttp401Response | EnableApi403,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof enableApi>>, TError, TData>
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getEnableApiQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof enableApi>>> = ({
    signal,
  }) => enableApi({ signal, ...fetchOptions });

  return { queryFn, queryKey, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof enableApi>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EnableApiQueryResult = NonNullable<
  Awaited<ReturnType<typeof enableApi>>
>;
export type EnableApiQueryError =
  | NHttp400Response
  | NHttp401Response
  | EnableApi403;

export function useEnableApi<
  TData = Awaited<ReturnType<typeof enableApi>>,
  TError = NHttp400Response | NHttp401Response | EnableApi403,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof enableApi>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof enableApi>>,
          TError,
          Awaited<ReturnType<typeof enableApi>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEnableApi<
  TData = Awaited<ReturnType<typeof enableApi>>,
  TError = NHttp400Response | NHttp401Response | EnableApi403,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof enableApi>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof enableApi>>,
          TError,
          Awaited<ReturnType<typeof enableApi>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useEnableApi<
  TData = Awaited<ReturnType<typeof enableApi>>,
  TError = NHttp400Response | NHttp401Response | EnableApi403,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof enableApi>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Enable API
 */

export function useEnableApi<
  TData = Awaited<ReturnType<typeof enableApi>>,
  TError = NHttp400Response | NHttp401Response | EnableApi403,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof enableApi>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getEnableApiQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Disable API (only with root permissions).
 * @summary Disable API
 */
export type disableApiResponse200 = {
  data: DisableApi200;
  status: 200;
};

export type disableApiResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type disableApiResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type disableApiResponse403 = {
  data: DisableApi403;
  status: 403;
};

export type disableApiResponseSuccess = disableApiResponse200 & {
  headers: Headers;
};
export type disableApiResponseError = (
  | disableApiResponse400
  | disableApiResponse401
  | disableApiResponse403
) & {
  headers: Headers;
};

export type disableApiResponse =
  | disableApiResponseSuccess
  | disableApiResponseError;

export const getDisableApiUrl = () => {
  return `https://coolify.tsar-bmb.org/disable`;
};

export const disableApi = async (
  options?: RequestInit,
): Promise<disableApiResponse> => {
  const res = await fetch(getDisableApiUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: disableApiResponse["data"] = body ? JSON.parse(body) : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as disableApiResponse;
};

export const getDisableApiQueryKey = () => {
  return [`https://coolify.tsar-bmb.org/disable`] as const;
};

export const getDisableApiQueryOptions = <
  TData = Awaited<ReturnType<typeof disableApi>>,
  TError = NHttp400Response | NHttp401Response | DisableApi403,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof disableApi>>, TError, TData>
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getDisableApiQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof disableApi>>> = ({
    signal,
  }) => disableApi({ signal, ...fetchOptions });

  return { queryFn, queryKey, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof disableApi>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DisableApiQueryResult = NonNullable<
  Awaited<ReturnType<typeof disableApi>>
>;
export type DisableApiQueryError =
  | NHttp400Response
  | NHttp401Response
  | DisableApi403;

export function useDisableApi<
  TData = Awaited<ReturnType<typeof disableApi>>,
  TError = NHttp400Response | NHttp401Response | DisableApi403,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof disableApi>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof disableApi>>,
          TError,
          Awaited<ReturnType<typeof disableApi>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDisableApi<
  TData = Awaited<ReturnType<typeof disableApi>>,
  TError = NHttp400Response | NHttp401Response | DisableApi403,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof disableApi>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof disableApi>>,
          TError,
          Awaited<ReturnType<typeof disableApi>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDisableApi<
  TData = Awaited<ReturnType<typeof disableApi>>,
  TError = NHttp400Response | NHttp401Response | DisableApi403,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof disableApi>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Disable API
 */

export function useDisableApi<
  TData = Awaited<ReturnType<typeof disableApi>>,
  TError = NHttp400Response | NHttp401Response | DisableApi403,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof disableApi>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getDisableApiQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Healthcheck endpoint.
 * @summary Healthcheck
 */
export type healthcheckResponse200 = {
  data: string;
  status: 200;
};

export type healthcheckResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type healthcheckResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type healthcheckResponseSuccess = healthcheckResponse200 & {
  headers: Headers;
};
export type healthcheckResponseError = (
  | healthcheckResponse400
  | healthcheckResponse401
) & {
  headers: Headers;
};

export type healthcheckResponse =
  | healthcheckResponseSuccess
  | healthcheckResponseError;

export const getHealthcheckUrl = () => {
  return `https://coolify.tsar-bmb.org/health`;
};

export const healthcheck = async (
  options?: RequestInit,
): Promise<healthcheckResponse> => {
  const res = await fetch(getHealthcheckUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: healthcheckResponse["data"] = body ? JSON.parse(body) : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as healthcheckResponse;
};

export const getHealthcheckQueryKey = () => {
  return [`https://coolify.tsar-bmb.org/health`] as const;
};

export const getHealthcheckQueryOptions = <
  TData = Awaited<ReturnType<typeof healthcheck>>,
  TError = NHttp400Response | NHttp401Response,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthcheck>>, TError, TData>
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHealthcheckQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthcheck>>> = ({
    signal,
  }) => healthcheck({ signal, ...fetchOptions });

  return { queryFn, queryKey, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof healthcheck>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HealthcheckQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthcheck>>
>;
export type HealthcheckQueryError = NHttp400Response | NHttp401Response;

export function useHealthcheck<
  TData = Awaited<ReturnType<typeof healthcheck>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthcheck>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthcheck>>,
          TError,
          Awaited<ReturnType<typeof healthcheck>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthcheck<
  TData = Awaited<ReturnType<typeof healthcheck>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthcheck>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthcheck>>,
          TError,
          Awaited<ReturnType<typeof healthcheck>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthcheck<
  TData = Awaited<ReturnType<typeof healthcheck>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthcheck>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Healthcheck
 */

export function useHealthcheck<
  TData = Awaited<ReturnType<typeof healthcheck>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthcheck>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getHealthcheckQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}
