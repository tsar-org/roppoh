/**
 * Generated by orval v7.12.2 üç∫
 * Do not edit manually.
 * Coolify
 * OpenAPI spec version: 0.1
 */

import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useSuspenseQuery,
} from "@tanstack/react-query";

import type {
  CreateDatabaseClickhouseBodies,
  CreateDatabaseDragonflyBodies,
  CreateDatabaseKeydbBodies,
  CreateDatabaseMariadbBodies,
  CreateDatabaseMongodbBodies,
  CreateDatabaseMysqlBodies,
  CreateDatabasePostgresqlBodies,
  CreateDatabaseRedisBodies,
  DeleteDatabaseByUuid200,
  DeleteDatabaseByUuidParams,
  NHttp400Response,
  NHttp401Response,
  NHttp404Response,
  RestartDatabaseByUuid200,
  StartDatabaseByUuid200,
  StopDatabaseByUuid200,
  UpdateDatabaseByUuidBodies,
} from ".././model";

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

/**
 * List all databases.
 * @summary List
 */
export type listDatabasesResponse200 = {
  data: string;
  status: 200;
};

export type listDatabasesResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type listDatabasesResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type listDatabasesResponseSuccess = listDatabasesResponse200 & {
  headers: Headers;
};
export type listDatabasesResponseError = (
  | listDatabasesResponse400
  | listDatabasesResponse401
) & {
  headers: Headers;
};

export type listDatabasesResponse =
  | listDatabasesResponseSuccess
  | listDatabasesResponseError;

export const getListDatabasesUrl = () => {
  return `/api/coolify/databases`;
};

export const listDatabases = async (
  options?: RequestInit,
): Promise<listDatabasesResponse> => {
  const res = await fetch(getListDatabasesUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: listDatabasesResponse["data"] = body ? JSON.parse(body) : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as listDatabasesResponse;
};

export const getListDatabasesQueryKey = () => {
  return [`/api/coolify/databases`] as const;
};

export const getListDatabasesInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof listDatabases>>>,
  TError = NHttp400Response | NHttp401Response,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof listDatabases>>,
      TError,
      TData
    >
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListDatabasesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listDatabases>>> = ({
    signal,
  }) => listDatabases({ signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof listDatabases>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListDatabasesInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof listDatabases>>
>;
export type ListDatabasesInfiniteQueryError =
  | NHttp400Response
  | NHttp401Response;

export function useListDatabasesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof listDatabases>>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listDatabases>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDatabases>>,
          TError,
          Awaited<ReturnType<typeof listDatabases>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListDatabasesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof listDatabases>>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listDatabases>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDatabases>>,
          TError,
          Awaited<ReturnType<typeof listDatabases>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListDatabasesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof listDatabases>>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listDatabases>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List
 */

export function useListDatabasesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof listDatabases>>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listDatabases>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getListDatabasesInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary List
 */
export const prefetchListDatabasesInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof listDatabases>>,
  TError = NHttp400Response | NHttp401Response,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listDatabases>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getListDatabasesInfiniteQueryOptions(options);

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const getListDatabasesQueryOptions = <
  TData = Awaited<ReturnType<typeof listDatabases>>,
  TError = NHttp400Response | NHttp401Response,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listDatabases>>, TError, TData>
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListDatabasesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listDatabases>>> = ({
    signal,
  }) => listDatabases({ signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof listDatabases>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListDatabasesQueryResult = NonNullable<
  Awaited<ReturnType<typeof listDatabases>>
>;
export type ListDatabasesQueryError = NHttp400Response | NHttp401Response;

export function useListDatabases<
  TData = Awaited<ReturnType<typeof listDatabases>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listDatabases>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDatabases>>,
          TError,
          Awaited<ReturnType<typeof listDatabases>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListDatabases<
  TData = Awaited<ReturnType<typeof listDatabases>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listDatabases>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDatabases>>,
          TError,
          Awaited<ReturnType<typeof listDatabases>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListDatabases<
  TData = Awaited<ReturnType<typeof listDatabases>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listDatabases>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List
 */

export function useListDatabases<
  TData = Awaited<ReturnType<typeof listDatabases>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listDatabases>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getListDatabasesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary List
 */
export const prefetchListDatabasesQuery = async <
  TData = Awaited<ReturnType<typeof listDatabases>>,
  TError = NHttp400Response | NHttp401Response,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listDatabases>>, TError, TData>
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getListDatabasesQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getListDatabasesSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof listDatabases>>,
  TError = NHttp400Response | NHttp401Response,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof listDatabases>>,
      TError,
      TData
    >
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListDatabasesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listDatabases>>> = ({
    signal,
  }) => listDatabases({ signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof listDatabases>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListDatabasesSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof listDatabases>>
>;
export type ListDatabasesSuspenseQueryError =
  | NHttp400Response
  | NHttp401Response;

export function useListDatabasesSuspense<
  TData = Awaited<ReturnType<typeof listDatabases>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof listDatabases>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListDatabasesSuspense<
  TData = Awaited<ReturnType<typeof listDatabases>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof listDatabases>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListDatabasesSuspense<
  TData = Awaited<ReturnType<typeof listDatabases>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof listDatabases>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List
 */

export function useListDatabasesSuspense<
  TData = Awaited<ReturnType<typeof listDatabases>>,
  TError = NHttp400Response | NHttp401Response,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof listDatabases>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getListDatabasesSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get database by UUID.
 * @summary Get
 */
export type getDatabaseByUuidResponse200 = {
  data: string;
  status: 200;
};

export type getDatabaseByUuidResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type getDatabaseByUuidResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type getDatabaseByUuidResponse404 = {
  data: NHttp404Response;
  status: 404;
};

export type getDatabaseByUuidResponseSuccess = getDatabaseByUuidResponse200 & {
  headers: Headers;
};
export type getDatabaseByUuidResponseError = (
  | getDatabaseByUuidResponse400
  | getDatabaseByUuidResponse401
  | getDatabaseByUuidResponse404
) & {
  headers: Headers;
};

export type getDatabaseByUuidResponse =
  | getDatabaseByUuidResponseSuccess
  | getDatabaseByUuidResponseError;

export const getGetDatabaseByUuidUrl = (uuid: string) => {
  return `/api/coolify/databases/${uuid}`;
};

export const getDatabaseByUuid = async (
  uuid: string,
  options?: RequestInit,
): Promise<getDatabaseByUuidResponse> => {
  const res = await fetch(getGetDatabaseByUuidUrl(uuid), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getDatabaseByUuidResponse["data"] = body ? JSON.parse(body) : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as getDatabaseByUuidResponse;
};

export const getGetDatabaseByUuidQueryKey = (uuid?: string) => {
  return [`/api/coolify/databases/${uuid}`] as const;
};

export const getGetDatabaseByUuidInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getDatabaseByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDatabaseByUuidQueryKey(uuid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDatabaseByUuid>>
  > = ({ signal }) => getDatabaseByUuid(uuid, { signal, ...fetchOptions });

  return {
    enabled: !!uuid,
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getDatabaseByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDatabaseByUuidInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDatabaseByUuid>>
>;
export type GetDatabaseByUuidInfiniteQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useGetDatabaseByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDatabaseByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getDatabaseByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDatabaseByUuid>>,
          TError,
          Awaited<ReturnType<typeof getDatabaseByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDatabaseByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDatabaseByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getDatabaseByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDatabaseByUuid>>,
          TError,
          Awaited<ReturnType<typeof getDatabaseByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDatabaseByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDatabaseByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get
 */

export function useGetDatabaseByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDatabaseByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetDatabaseByUuidInfiniteQueryOptions(uuid, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get
 */
export const prefetchGetDatabaseByUuidInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  queryClient: QueryClient,
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetDatabaseByUuidInfiniteQueryOptions(uuid, options);

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const getGetDatabaseByUuidQueryOptions = <
  TData = Awaited<ReturnType<typeof getDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDatabaseByUuidQueryKey(uuid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDatabaseByUuid>>
  > = ({ signal }) => getDatabaseByUuid(uuid, { signal, ...fetchOptions });

  return {
    enabled: !!uuid,
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getDatabaseByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDatabaseByUuidQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDatabaseByUuid>>
>;
export type GetDatabaseByUuidQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useGetDatabaseByUuid<
  TData = Awaited<ReturnType<typeof getDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDatabaseByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDatabaseByUuid>>,
          TError,
          Awaited<ReturnType<typeof getDatabaseByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDatabaseByUuid<
  TData = Awaited<ReturnType<typeof getDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDatabaseByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDatabaseByUuid>>,
          TError,
          Awaited<ReturnType<typeof getDatabaseByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDatabaseByUuid<
  TData = Awaited<ReturnType<typeof getDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get
 */

export function useGetDatabaseByUuid<
  TData = Awaited<ReturnType<typeof getDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetDatabaseByUuidQueryOptions(uuid, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get
 */
export const prefetchGetDatabaseByUuidQuery = async <
  TData = Awaited<ReturnType<typeof getDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  queryClient: QueryClient,
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetDatabaseByUuidQueryOptions(uuid, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getGetDatabaseByUuidSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDatabaseByUuidQueryKey(uuid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDatabaseByUuid>>
  > = ({ signal }) => getDatabaseByUuid(uuid, { signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getDatabaseByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDatabaseByUuidSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDatabaseByUuid>>
>;
export type GetDatabaseByUuidSuspenseQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useGetDatabaseByUuidSuspense<
  TData = Awaited<ReturnType<typeof getDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDatabaseByUuidSuspense<
  TData = Awaited<ReturnType<typeof getDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDatabaseByUuidSuspense<
  TData = Awaited<ReturnType<typeof getDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get
 */

export function useGetDatabaseByUuidSuspense<
  TData = Awaited<ReturnType<typeof getDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetDatabaseByUuidSuspenseQueryOptions(uuid, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete database by UUID.
 * @summary Delete
 */
export type deleteDatabaseByUuidResponse200 = {
  data: DeleteDatabaseByUuid200;
  status: 200;
};

export type deleteDatabaseByUuidResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type deleteDatabaseByUuidResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type deleteDatabaseByUuidResponse404 = {
  data: NHttp404Response;
  status: 404;
};

export type deleteDatabaseByUuidResponseSuccess =
  deleteDatabaseByUuidResponse200 & {
    headers: Headers;
  };
export type deleteDatabaseByUuidResponseError = (
  | deleteDatabaseByUuidResponse400
  | deleteDatabaseByUuidResponse401
  | deleteDatabaseByUuidResponse404
) & {
  headers: Headers;
};

export type deleteDatabaseByUuidResponse =
  | deleteDatabaseByUuidResponseSuccess
  | deleteDatabaseByUuidResponseError;

export const getDeleteDatabaseByUuidUrl = (
  uuid: string,
  params?: DeleteDatabaseByUuidParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/coolify/databases/${uuid}?${stringifiedParams}`
    : `/api/coolify/databases/${uuid}`;
};

export const deleteDatabaseByUuid = async (
  uuid: string,
  params?: DeleteDatabaseByUuidParams,
  options?: RequestInit,
): Promise<deleteDatabaseByUuidResponse> => {
  const res = await fetch(getDeleteDatabaseByUuidUrl(uuid, params), {
    ...options,
    method: "DELETE",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: deleteDatabaseByUuidResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as deleteDatabaseByUuidResponse;
};

export const getDeleteDatabaseByUuidMutationOptions = <
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteDatabaseByUuid>>,
    TError,
    { uuid: string; params?: DeleteDatabaseByUuidParams },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteDatabaseByUuid>>,
  TError,
  { uuid: string; params?: DeleteDatabaseByUuidParams },
  TContext
> => {
  const mutationKey = ["deleteDatabaseByUuid"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { fetch: undefined, mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteDatabaseByUuid>>,
    { uuid: string; params?: DeleteDatabaseByUuidParams }
  > = (props) => {
    const { uuid, params } = props ?? {};

    return deleteDatabaseByUuid(uuid, params, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteDatabaseByUuidMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteDatabaseByUuid>>
>;

export type DeleteDatabaseByUuidMutationError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

/**
 * @summary Delete
 */
export const useDeleteDatabaseByUuid = <
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteDatabaseByUuid>>,
      TError,
      { uuid: string; params?: DeleteDatabaseByUuidParams },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteDatabaseByUuid>>,
  TError,
  { uuid: string; params?: DeleteDatabaseByUuidParams },
  TContext
> => {
  const mutationOptions = getDeleteDatabaseByUuidMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Update database by UUID.
 * @summary Update
 */
export type updateDatabaseByUuidResponse200 = {
  data: void;
  status: 200;
};

export type updateDatabaseByUuidResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type updateDatabaseByUuidResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type updateDatabaseByUuidResponse404 = {
  data: NHttp404Response;
  status: 404;
};

export type updateDatabaseByUuidResponseSuccess =
  updateDatabaseByUuidResponse200 & {
    headers: Headers;
  };
export type updateDatabaseByUuidResponseError = (
  | updateDatabaseByUuidResponse400
  | updateDatabaseByUuidResponse401
  | updateDatabaseByUuidResponse404
) & {
  headers: Headers;
};

export type updateDatabaseByUuidResponse =
  | updateDatabaseByUuidResponseSuccess
  | updateDatabaseByUuidResponseError;

export const getUpdateDatabaseByUuidUrl = (uuid: string) => {
  return `/api/coolify/databases/${uuid}`;
};

export const updateDatabaseByUuid = async (
  uuid: string,
  updateDatabaseByUuidBodies: UpdateDatabaseByUuidBodies,
  options?: RequestInit,
): Promise<updateDatabaseByUuidResponse> => {
  const res = await fetch(getUpdateDatabaseByUuidUrl(uuid), {
    ...options,
    body: JSON.stringify(updateDatabaseByUuidBodies),
    headers: { "Content-Type": "application/json", ...options?.headers },
    method: "PATCH",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: updateDatabaseByUuidResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as updateDatabaseByUuidResponse;
};

export const getUpdateDatabaseByUuidMutationOptions = <
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateDatabaseByUuid>>,
    TError,
    { uuid: string; data: UpdateDatabaseByUuidBodies },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateDatabaseByUuid>>,
  TError,
  { uuid: string; data: UpdateDatabaseByUuidBodies },
  TContext
> => {
  const mutationKey = ["updateDatabaseByUuid"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { fetch: undefined, mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateDatabaseByUuid>>,
    { uuid: string; data: UpdateDatabaseByUuidBodies }
  > = (props) => {
    const { uuid, data } = props ?? {};

    return updateDatabaseByUuid(uuid, data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateDatabaseByUuidMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateDatabaseByUuid>>
>;
export type UpdateDatabaseByUuidMutationBody = UpdateDatabaseByUuidBodies;
export type UpdateDatabaseByUuidMutationError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

/**
 * @summary Update
 */
export const useUpdateDatabaseByUuid = <
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateDatabaseByUuid>>,
      TError,
      { uuid: string; data: UpdateDatabaseByUuidBodies },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateDatabaseByUuid>>,
  TError,
  { uuid: string; data: UpdateDatabaseByUuidBodies },
  TContext
> => {
  const mutationOptions = getUpdateDatabaseByUuidMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Create a new PostgreSQL database.
 * @summary Create (PostgreSQL)
 */
export type createDatabasePostgresqlResponse200 = {
  data: void;
  status: 200;
};

export type createDatabasePostgresqlResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type createDatabasePostgresqlResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type createDatabasePostgresqlResponseSuccess =
  createDatabasePostgresqlResponse200 & {
    headers: Headers;
  };
export type createDatabasePostgresqlResponseError = (
  | createDatabasePostgresqlResponse400
  | createDatabasePostgresqlResponse401
) & {
  headers: Headers;
};

export type createDatabasePostgresqlResponse =
  | createDatabasePostgresqlResponseSuccess
  | createDatabasePostgresqlResponseError;

export const getCreateDatabasePostgresqlUrl = () => {
  return `/api/coolify/databases/postgresql`;
};

export const createDatabasePostgresql = async (
  createDatabasePostgresqlBodies: CreateDatabasePostgresqlBodies,
  options?: RequestInit,
): Promise<createDatabasePostgresqlResponse> => {
  const res = await fetch(getCreateDatabasePostgresqlUrl(), {
    ...options,
    body: JSON.stringify(createDatabasePostgresqlBodies),
    headers: { "Content-Type": "application/json", ...options?.headers },
    method: "POST",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: createDatabasePostgresqlResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as createDatabasePostgresqlResponse;
};

export const getCreateDatabasePostgresqlMutationOptions = <
  TError = NHttp400Response | NHttp401Response,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createDatabasePostgresql>>,
    TError,
    { data: CreateDatabasePostgresqlBodies },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createDatabasePostgresql>>,
  TError,
  { data: CreateDatabasePostgresqlBodies },
  TContext
> => {
  const mutationKey = ["createDatabasePostgresql"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { fetch: undefined, mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createDatabasePostgresql>>,
    { data: CreateDatabasePostgresqlBodies }
  > = (props) => {
    const { data } = props ?? {};

    return createDatabasePostgresql(data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateDatabasePostgresqlMutationResult = NonNullable<
  Awaited<ReturnType<typeof createDatabasePostgresql>>
>;
export type CreateDatabasePostgresqlMutationBody =
  CreateDatabasePostgresqlBodies;
export type CreateDatabasePostgresqlMutationError =
  | NHttp400Response
  | NHttp401Response;

/**
 * @summary Create (PostgreSQL)
 */
export const useCreateDatabasePostgresql = <
  TError = NHttp400Response | NHttp401Response,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createDatabasePostgresql>>,
      TError,
      { data: CreateDatabasePostgresqlBodies },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createDatabasePostgresql>>,
  TError,
  { data: CreateDatabasePostgresqlBodies },
  TContext
> => {
  const mutationOptions = getCreateDatabasePostgresqlMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Create a new Clickhouse database.
 * @summary Create (Clickhouse)
 */
export type createDatabaseClickhouseResponse200 = {
  data: void;
  status: 200;
};

export type createDatabaseClickhouseResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type createDatabaseClickhouseResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type createDatabaseClickhouseResponseSuccess =
  createDatabaseClickhouseResponse200 & {
    headers: Headers;
  };
export type createDatabaseClickhouseResponseError = (
  | createDatabaseClickhouseResponse400
  | createDatabaseClickhouseResponse401
) & {
  headers: Headers;
};

export type createDatabaseClickhouseResponse =
  | createDatabaseClickhouseResponseSuccess
  | createDatabaseClickhouseResponseError;

export const getCreateDatabaseClickhouseUrl = () => {
  return `/api/coolify/databases/clickhouse`;
};

export const createDatabaseClickhouse = async (
  createDatabaseClickhouseBodies: CreateDatabaseClickhouseBodies,
  options?: RequestInit,
): Promise<createDatabaseClickhouseResponse> => {
  const res = await fetch(getCreateDatabaseClickhouseUrl(), {
    ...options,
    body: JSON.stringify(createDatabaseClickhouseBodies),
    headers: { "Content-Type": "application/json", ...options?.headers },
    method: "POST",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: createDatabaseClickhouseResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as createDatabaseClickhouseResponse;
};

export const getCreateDatabaseClickhouseMutationOptions = <
  TError = NHttp400Response | NHttp401Response,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createDatabaseClickhouse>>,
    TError,
    { data: CreateDatabaseClickhouseBodies },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createDatabaseClickhouse>>,
  TError,
  { data: CreateDatabaseClickhouseBodies },
  TContext
> => {
  const mutationKey = ["createDatabaseClickhouse"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { fetch: undefined, mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createDatabaseClickhouse>>,
    { data: CreateDatabaseClickhouseBodies }
  > = (props) => {
    const { data } = props ?? {};

    return createDatabaseClickhouse(data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateDatabaseClickhouseMutationResult = NonNullable<
  Awaited<ReturnType<typeof createDatabaseClickhouse>>
>;
export type CreateDatabaseClickhouseMutationBody =
  CreateDatabaseClickhouseBodies;
export type CreateDatabaseClickhouseMutationError =
  | NHttp400Response
  | NHttp401Response;

/**
 * @summary Create (Clickhouse)
 */
export const useCreateDatabaseClickhouse = <
  TError = NHttp400Response | NHttp401Response,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createDatabaseClickhouse>>,
      TError,
      { data: CreateDatabaseClickhouseBodies },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createDatabaseClickhouse>>,
  TError,
  { data: CreateDatabaseClickhouseBodies },
  TContext
> => {
  const mutationOptions = getCreateDatabaseClickhouseMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Create a new DragonFly database.
 * @summary Create (DragonFly)
 */
export type createDatabaseDragonflyResponse200 = {
  data: void;
  status: 200;
};

export type createDatabaseDragonflyResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type createDatabaseDragonflyResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type createDatabaseDragonflyResponseSuccess =
  createDatabaseDragonflyResponse200 & {
    headers: Headers;
  };
export type createDatabaseDragonflyResponseError = (
  | createDatabaseDragonflyResponse400
  | createDatabaseDragonflyResponse401
) & {
  headers: Headers;
};

export type createDatabaseDragonflyResponse =
  | createDatabaseDragonflyResponseSuccess
  | createDatabaseDragonflyResponseError;

export const getCreateDatabaseDragonflyUrl = () => {
  return `/api/coolify/databases/dragonfly`;
};

export const createDatabaseDragonfly = async (
  createDatabaseDragonflyBodies: CreateDatabaseDragonflyBodies,
  options?: RequestInit,
): Promise<createDatabaseDragonflyResponse> => {
  const res = await fetch(getCreateDatabaseDragonflyUrl(), {
    ...options,
    body: JSON.stringify(createDatabaseDragonflyBodies),
    headers: { "Content-Type": "application/json", ...options?.headers },
    method: "POST",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: createDatabaseDragonflyResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as createDatabaseDragonflyResponse;
};

export const getCreateDatabaseDragonflyMutationOptions = <
  TError = NHttp400Response | NHttp401Response,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createDatabaseDragonfly>>,
    TError,
    { data: CreateDatabaseDragonflyBodies },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createDatabaseDragonfly>>,
  TError,
  { data: CreateDatabaseDragonflyBodies },
  TContext
> => {
  const mutationKey = ["createDatabaseDragonfly"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { fetch: undefined, mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createDatabaseDragonfly>>,
    { data: CreateDatabaseDragonflyBodies }
  > = (props) => {
    const { data } = props ?? {};

    return createDatabaseDragonfly(data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateDatabaseDragonflyMutationResult = NonNullable<
  Awaited<ReturnType<typeof createDatabaseDragonfly>>
>;
export type CreateDatabaseDragonflyMutationBody = CreateDatabaseDragonflyBodies;
export type CreateDatabaseDragonflyMutationError =
  | NHttp400Response
  | NHttp401Response;

/**
 * @summary Create (DragonFly)
 */
export const useCreateDatabaseDragonfly = <
  TError = NHttp400Response | NHttp401Response,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createDatabaseDragonfly>>,
      TError,
      { data: CreateDatabaseDragonflyBodies },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createDatabaseDragonfly>>,
  TError,
  { data: CreateDatabaseDragonflyBodies },
  TContext
> => {
  const mutationOptions = getCreateDatabaseDragonflyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Create a new Redis database.
 * @summary Create (Redis)
 */
export type createDatabaseRedisResponse200 = {
  data: void;
  status: 200;
};

export type createDatabaseRedisResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type createDatabaseRedisResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type createDatabaseRedisResponseSuccess =
  createDatabaseRedisResponse200 & {
    headers: Headers;
  };
export type createDatabaseRedisResponseError = (
  | createDatabaseRedisResponse400
  | createDatabaseRedisResponse401
) & {
  headers: Headers;
};

export type createDatabaseRedisResponse =
  | createDatabaseRedisResponseSuccess
  | createDatabaseRedisResponseError;

export const getCreateDatabaseRedisUrl = () => {
  return `/api/coolify/databases/redis`;
};

export const createDatabaseRedis = async (
  createDatabaseRedisBodies: CreateDatabaseRedisBodies,
  options?: RequestInit,
): Promise<createDatabaseRedisResponse> => {
  const res = await fetch(getCreateDatabaseRedisUrl(), {
    ...options,
    body: JSON.stringify(createDatabaseRedisBodies),
    headers: { "Content-Type": "application/json", ...options?.headers },
    method: "POST",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: createDatabaseRedisResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as createDatabaseRedisResponse;
};

export const getCreateDatabaseRedisMutationOptions = <
  TError = NHttp400Response | NHttp401Response,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createDatabaseRedis>>,
    TError,
    { data: CreateDatabaseRedisBodies },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createDatabaseRedis>>,
  TError,
  { data: CreateDatabaseRedisBodies },
  TContext
> => {
  const mutationKey = ["createDatabaseRedis"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { fetch: undefined, mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createDatabaseRedis>>,
    { data: CreateDatabaseRedisBodies }
  > = (props) => {
    const { data } = props ?? {};

    return createDatabaseRedis(data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateDatabaseRedisMutationResult = NonNullable<
  Awaited<ReturnType<typeof createDatabaseRedis>>
>;
export type CreateDatabaseRedisMutationBody = CreateDatabaseRedisBodies;
export type CreateDatabaseRedisMutationError =
  | NHttp400Response
  | NHttp401Response;

/**
 * @summary Create (Redis)
 */
export const useCreateDatabaseRedis = <
  TError = NHttp400Response | NHttp401Response,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createDatabaseRedis>>,
      TError,
      { data: CreateDatabaseRedisBodies },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createDatabaseRedis>>,
  TError,
  { data: CreateDatabaseRedisBodies },
  TContext
> => {
  const mutationOptions = getCreateDatabaseRedisMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Create a new KeyDB database.
 * @summary Create (KeyDB)
 */
export type createDatabaseKeydbResponse200 = {
  data: void;
  status: 200;
};

export type createDatabaseKeydbResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type createDatabaseKeydbResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type createDatabaseKeydbResponseSuccess =
  createDatabaseKeydbResponse200 & {
    headers: Headers;
  };
export type createDatabaseKeydbResponseError = (
  | createDatabaseKeydbResponse400
  | createDatabaseKeydbResponse401
) & {
  headers: Headers;
};

export type createDatabaseKeydbResponse =
  | createDatabaseKeydbResponseSuccess
  | createDatabaseKeydbResponseError;

export const getCreateDatabaseKeydbUrl = () => {
  return `/api/coolify/databases/keydb`;
};

export const createDatabaseKeydb = async (
  createDatabaseKeydbBodies: CreateDatabaseKeydbBodies,
  options?: RequestInit,
): Promise<createDatabaseKeydbResponse> => {
  const res = await fetch(getCreateDatabaseKeydbUrl(), {
    ...options,
    body: JSON.stringify(createDatabaseKeydbBodies),
    headers: { "Content-Type": "application/json", ...options?.headers },
    method: "POST",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: createDatabaseKeydbResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as createDatabaseKeydbResponse;
};

export const getCreateDatabaseKeydbMutationOptions = <
  TError = NHttp400Response | NHttp401Response,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createDatabaseKeydb>>,
    TError,
    { data: CreateDatabaseKeydbBodies },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createDatabaseKeydb>>,
  TError,
  { data: CreateDatabaseKeydbBodies },
  TContext
> => {
  const mutationKey = ["createDatabaseKeydb"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { fetch: undefined, mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createDatabaseKeydb>>,
    { data: CreateDatabaseKeydbBodies }
  > = (props) => {
    const { data } = props ?? {};

    return createDatabaseKeydb(data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateDatabaseKeydbMutationResult = NonNullable<
  Awaited<ReturnType<typeof createDatabaseKeydb>>
>;
export type CreateDatabaseKeydbMutationBody = CreateDatabaseKeydbBodies;
export type CreateDatabaseKeydbMutationError =
  | NHttp400Response
  | NHttp401Response;

/**
 * @summary Create (KeyDB)
 */
export const useCreateDatabaseKeydb = <
  TError = NHttp400Response | NHttp401Response,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createDatabaseKeydb>>,
      TError,
      { data: CreateDatabaseKeydbBodies },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createDatabaseKeydb>>,
  TError,
  { data: CreateDatabaseKeydbBodies },
  TContext
> => {
  const mutationOptions = getCreateDatabaseKeydbMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Create a new MariaDB database.
 * @summary Create (MariaDB)
 */
export type createDatabaseMariadbResponse200 = {
  data: void;
  status: 200;
};

export type createDatabaseMariadbResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type createDatabaseMariadbResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type createDatabaseMariadbResponseSuccess =
  createDatabaseMariadbResponse200 & {
    headers: Headers;
  };
export type createDatabaseMariadbResponseError = (
  | createDatabaseMariadbResponse400
  | createDatabaseMariadbResponse401
) & {
  headers: Headers;
};

export type createDatabaseMariadbResponse =
  | createDatabaseMariadbResponseSuccess
  | createDatabaseMariadbResponseError;

export const getCreateDatabaseMariadbUrl = () => {
  return `/api/coolify/databases/mariadb`;
};

export const createDatabaseMariadb = async (
  createDatabaseMariadbBodies: CreateDatabaseMariadbBodies,
  options?: RequestInit,
): Promise<createDatabaseMariadbResponse> => {
  const res = await fetch(getCreateDatabaseMariadbUrl(), {
    ...options,
    body: JSON.stringify(createDatabaseMariadbBodies),
    headers: { "Content-Type": "application/json", ...options?.headers },
    method: "POST",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: createDatabaseMariadbResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as createDatabaseMariadbResponse;
};

export const getCreateDatabaseMariadbMutationOptions = <
  TError = NHttp400Response | NHttp401Response,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createDatabaseMariadb>>,
    TError,
    { data: CreateDatabaseMariadbBodies },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createDatabaseMariadb>>,
  TError,
  { data: CreateDatabaseMariadbBodies },
  TContext
> => {
  const mutationKey = ["createDatabaseMariadb"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { fetch: undefined, mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createDatabaseMariadb>>,
    { data: CreateDatabaseMariadbBodies }
  > = (props) => {
    const { data } = props ?? {};

    return createDatabaseMariadb(data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateDatabaseMariadbMutationResult = NonNullable<
  Awaited<ReturnType<typeof createDatabaseMariadb>>
>;
export type CreateDatabaseMariadbMutationBody = CreateDatabaseMariadbBodies;
export type CreateDatabaseMariadbMutationError =
  | NHttp400Response
  | NHttp401Response;

/**
 * @summary Create (MariaDB)
 */
export const useCreateDatabaseMariadb = <
  TError = NHttp400Response | NHttp401Response,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createDatabaseMariadb>>,
      TError,
      { data: CreateDatabaseMariadbBodies },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createDatabaseMariadb>>,
  TError,
  { data: CreateDatabaseMariadbBodies },
  TContext
> => {
  const mutationOptions = getCreateDatabaseMariadbMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Create a new MySQL database.
 * @summary Create (MySQL)
 */
export type createDatabaseMysqlResponse200 = {
  data: void;
  status: 200;
};

export type createDatabaseMysqlResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type createDatabaseMysqlResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type createDatabaseMysqlResponseSuccess =
  createDatabaseMysqlResponse200 & {
    headers: Headers;
  };
export type createDatabaseMysqlResponseError = (
  | createDatabaseMysqlResponse400
  | createDatabaseMysqlResponse401
) & {
  headers: Headers;
};

export type createDatabaseMysqlResponse =
  | createDatabaseMysqlResponseSuccess
  | createDatabaseMysqlResponseError;

export const getCreateDatabaseMysqlUrl = () => {
  return `/api/coolify/databases/mysql`;
};

export const createDatabaseMysql = async (
  createDatabaseMysqlBodies: CreateDatabaseMysqlBodies,
  options?: RequestInit,
): Promise<createDatabaseMysqlResponse> => {
  const res = await fetch(getCreateDatabaseMysqlUrl(), {
    ...options,
    body: JSON.stringify(createDatabaseMysqlBodies),
    headers: { "Content-Type": "application/json", ...options?.headers },
    method: "POST",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: createDatabaseMysqlResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as createDatabaseMysqlResponse;
};

export const getCreateDatabaseMysqlMutationOptions = <
  TError = NHttp400Response | NHttp401Response,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createDatabaseMysql>>,
    TError,
    { data: CreateDatabaseMysqlBodies },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createDatabaseMysql>>,
  TError,
  { data: CreateDatabaseMysqlBodies },
  TContext
> => {
  const mutationKey = ["createDatabaseMysql"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { fetch: undefined, mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createDatabaseMysql>>,
    { data: CreateDatabaseMysqlBodies }
  > = (props) => {
    const { data } = props ?? {};

    return createDatabaseMysql(data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateDatabaseMysqlMutationResult = NonNullable<
  Awaited<ReturnType<typeof createDatabaseMysql>>
>;
export type CreateDatabaseMysqlMutationBody = CreateDatabaseMysqlBodies;
export type CreateDatabaseMysqlMutationError =
  | NHttp400Response
  | NHttp401Response;

/**
 * @summary Create (MySQL)
 */
export const useCreateDatabaseMysql = <
  TError = NHttp400Response | NHttp401Response,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createDatabaseMysql>>,
      TError,
      { data: CreateDatabaseMysqlBodies },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createDatabaseMysql>>,
  TError,
  { data: CreateDatabaseMysqlBodies },
  TContext
> => {
  const mutationOptions = getCreateDatabaseMysqlMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Create a new MongoDB database.
 * @summary Create (MongoDB)
 */
export type createDatabaseMongodbResponse200 = {
  data: void;
  status: 200;
};

export type createDatabaseMongodbResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type createDatabaseMongodbResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type createDatabaseMongodbResponseSuccess =
  createDatabaseMongodbResponse200 & {
    headers: Headers;
  };
export type createDatabaseMongodbResponseError = (
  | createDatabaseMongodbResponse400
  | createDatabaseMongodbResponse401
) & {
  headers: Headers;
};

export type createDatabaseMongodbResponse =
  | createDatabaseMongodbResponseSuccess
  | createDatabaseMongodbResponseError;

export const getCreateDatabaseMongodbUrl = () => {
  return `/api/coolify/databases/mongodb`;
};

export const createDatabaseMongodb = async (
  createDatabaseMongodbBodies: CreateDatabaseMongodbBodies,
  options?: RequestInit,
): Promise<createDatabaseMongodbResponse> => {
  const res = await fetch(getCreateDatabaseMongodbUrl(), {
    ...options,
    body: JSON.stringify(createDatabaseMongodbBodies),
    headers: { "Content-Type": "application/json", ...options?.headers },
    method: "POST",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: createDatabaseMongodbResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as createDatabaseMongodbResponse;
};

export const getCreateDatabaseMongodbMutationOptions = <
  TError = NHttp400Response | NHttp401Response,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createDatabaseMongodb>>,
    TError,
    { data: CreateDatabaseMongodbBodies },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createDatabaseMongodb>>,
  TError,
  { data: CreateDatabaseMongodbBodies },
  TContext
> => {
  const mutationKey = ["createDatabaseMongodb"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { fetch: undefined, mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createDatabaseMongodb>>,
    { data: CreateDatabaseMongodbBodies }
  > = (props) => {
    const { data } = props ?? {};

    return createDatabaseMongodb(data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateDatabaseMongodbMutationResult = NonNullable<
  Awaited<ReturnType<typeof createDatabaseMongodb>>
>;
export type CreateDatabaseMongodbMutationBody = CreateDatabaseMongodbBodies;
export type CreateDatabaseMongodbMutationError =
  | NHttp400Response
  | NHttp401Response;

/**
 * @summary Create (MongoDB)
 */
export const useCreateDatabaseMongodb = <
  TError = NHttp400Response | NHttp401Response,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createDatabaseMongodb>>,
      TError,
      { data: CreateDatabaseMongodbBodies },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createDatabaseMongodb>>,
  TError,
  { data: CreateDatabaseMongodbBodies },
  TContext
> => {
  const mutationOptions = getCreateDatabaseMongodbMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Start database. `Post` request is also accepted.
 * @summary Start
 */
export type startDatabaseByUuidResponse200 = {
  data: StartDatabaseByUuid200;
  status: 200;
};

export type startDatabaseByUuidResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type startDatabaseByUuidResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type startDatabaseByUuidResponse404 = {
  data: NHttp404Response;
  status: 404;
};

export type startDatabaseByUuidResponseSuccess =
  startDatabaseByUuidResponse200 & {
    headers: Headers;
  };
export type startDatabaseByUuidResponseError = (
  | startDatabaseByUuidResponse400
  | startDatabaseByUuidResponse401
  | startDatabaseByUuidResponse404
) & {
  headers: Headers;
};

export type startDatabaseByUuidResponse =
  | startDatabaseByUuidResponseSuccess
  | startDatabaseByUuidResponseError;

export const getStartDatabaseByUuidUrl = (uuid: string) => {
  return `/api/coolify/databases/${uuid}/start`;
};

export const startDatabaseByUuid = async (
  uuid: string,
  options?: RequestInit,
): Promise<startDatabaseByUuidResponse> => {
  const res = await fetch(getStartDatabaseByUuidUrl(uuid), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: startDatabaseByUuidResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as startDatabaseByUuidResponse;
};

export const getStartDatabaseByUuidQueryKey = (uuid?: string) => {
  return [`/api/coolify/databases/${uuid}/start`] as const;
};

export const getStartDatabaseByUuidInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof startDatabaseByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof startDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStartDatabaseByUuidQueryKey(uuid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof startDatabaseByUuid>>
  > = ({ signal }) => startDatabaseByUuid(uuid, { signal, ...fetchOptions });

  return {
    enabled: !!uuid,
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof startDatabaseByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StartDatabaseByUuidInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof startDatabaseByUuid>>
>;
export type StartDatabaseByUuidInfiniteQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useStartDatabaseByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof startDatabaseByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof startDatabaseByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof startDatabaseByUuid>>,
          TError,
          Awaited<ReturnType<typeof startDatabaseByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStartDatabaseByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof startDatabaseByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof startDatabaseByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof startDatabaseByUuid>>,
          TError,
          Awaited<ReturnType<typeof startDatabaseByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStartDatabaseByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof startDatabaseByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof startDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Start
 */

export function useStartDatabaseByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof startDatabaseByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof startDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getStartDatabaseByUuidInfiniteQueryOptions(
    uuid,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Start
 */
export const prefetchStartDatabaseByUuidInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof startDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  queryClient: QueryClient,
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof startDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getStartDatabaseByUuidInfiniteQueryOptions(
    uuid,
    options,
  );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const getStartDatabaseByUuidQueryOptions = <
  TData = Awaited<ReturnType<typeof startDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStartDatabaseByUuidQueryKey(uuid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof startDatabaseByUuid>>
  > = ({ signal }) => startDatabaseByUuid(uuid, { signal, ...fetchOptions });

  return {
    enabled: !!uuid,
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof startDatabaseByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StartDatabaseByUuidQueryResult = NonNullable<
  Awaited<ReturnType<typeof startDatabaseByUuid>>
>;
export type StartDatabaseByUuidQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useStartDatabaseByUuid<
  TData = Awaited<ReturnType<typeof startDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startDatabaseByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof startDatabaseByUuid>>,
          TError,
          Awaited<ReturnType<typeof startDatabaseByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStartDatabaseByUuid<
  TData = Awaited<ReturnType<typeof startDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startDatabaseByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof startDatabaseByUuid>>,
          TError,
          Awaited<ReturnType<typeof startDatabaseByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStartDatabaseByUuid<
  TData = Awaited<ReturnType<typeof startDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Start
 */

export function useStartDatabaseByUuid<
  TData = Awaited<ReturnType<typeof startDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getStartDatabaseByUuidQueryOptions(uuid, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Start
 */
export const prefetchStartDatabaseByUuidQuery = async <
  TData = Awaited<ReturnType<typeof startDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  queryClient: QueryClient,
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof startDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getStartDatabaseByUuidQueryOptions(uuid, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getStartDatabaseByUuidSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof startDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof startDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStartDatabaseByUuidQueryKey(uuid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof startDatabaseByUuid>>
  > = ({ signal }) => startDatabaseByUuid(uuid, { signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof startDatabaseByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StartDatabaseByUuidSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof startDatabaseByUuid>>
>;
export type StartDatabaseByUuidSuspenseQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useStartDatabaseByUuidSuspense<
  TData = Awaited<ReturnType<typeof startDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof startDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStartDatabaseByUuidSuspense<
  TData = Awaited<ReturnType<typeof startDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof startDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStartDatabaseByUuidSuspense<
  TData = Awaited<ReturnType<typeof startDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof startDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Start
 */

export function useStartDatabaseByUuidSuspense<
  TData = Awaited<ReturnType<typeof startDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof startDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getStartDatabaseByUuidSuspenseQueryOptions(
    uuid,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Stop database. `Post` request is also accepted.
 * @summary Stop
 */
export type stopDatabaseByUuidResponse200 = {
  data: StopDatabaseByUuid200;
  status: 200;
};

export type stopDatabaseByUuidResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type stopDatabaseByUuidResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type stopDatabaseByUuidResponse404 = {
  data: NHttp404Response;
  status: 404;
};

export type stopDatabaseByUuidResponseSuccess =
  stopDatabaseByUuidResponse200 & {
    headers: Headers;
  };
export type stopDatabaseByUuidResponseError = (
  | stopDatabaseByUuidResponse400
  | stopDatabaseByUuidResponse401
  | stopDatabaseByUuidResponse404
) & {
  headers: Headers;
};

export type stopDatabaseByUuidResponse =
  | stopDatabaseByUuidResponseSuccess
  | stopDatabaseByUuidResponseError;

export const getStopDatabaseByUuidUrl = (uuid: string) => {
  return `/api/coolify/databases/${uuid}/stop`;
};

export const stopDatabaseByUuid = async (
  uuid: string,
  options?: RequestInit,
): Promise<stopDatabaseByUuidResponse> => {
  const res = await fetch(getStopDatabaseByUuidUrl(uuid), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: stopDatabaseByUuidResponse["data"] = body ? JSON.parse(body) : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as stopDatabaseByUuidResponse;
};

export const getStopDatabaseByUuidQueryKey = (uuid?: string) => {
  return [`/api/coolify/databases/${uuid}/stop`] as const;
};

export const getStopDatabaseByUuidInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof stopDatabaseByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof stopDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStopDatabaseByUuidQueryKey(uuid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof stopDatabaseByUuid>>
  > = ({ signal }) => stopDatabaseByUuid(uuid, { signal, ...fetchOptions });

  return {
    enabled: !!uuid,
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof stopDatabaseByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StopDatabaseByUuidInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof stopDatabaseByUuid>>
>;
export type StopDatabaseByUuidInfiniteQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useStopDatabaseByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof stopDatabaseByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof stopDatabaseByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stopDatabaseByUuid>>,
          TError,
          Awaited<ReturnType<typeof stopDatabaseByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStopDatabaseByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof stopDatabaseByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof stopDatabaseByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stopDatabaseByUuid>>,
          TError,
          Awaited<ReturnType<typeof stopDatabaseByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStopDatabaseByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof stopDatabaseByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof stopDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Stop
 */

export function useStopDatabaseByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof stopDatabaseByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof stopDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getStopDatabaseByUuidInfiniteQueryOptions(uuid, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Stop
 */
export const prefetchStopDatabaseByUuidInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof stopDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  queryClient: QueryClient,
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof stopDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getStopDatabaseByUuidInfiniteQueryOptions(uuid, options);

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const getStopDatabaseByUuidQueryOptions = <
  TData = Awaited<ReturnType<typeof stopDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof stopDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStopDatabaseByUuidQueryKey(uuid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof stopDatabaseByUuid>>
  > = ({ signal }) => stopDatabaseByUuid(uuid, { signal, ...fetchOptions });

  return {
    enabled: !!uuid,
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof stopDatabaseByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StopDatabaseByUuidQueryResult = NonNullable<
  Awaited<ReturnType<typeof stopDatabaseByUuid>>
>;
export type StopDatabaseByUuidQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useStopDatabaseByUuid<
  TData = Awaited<ReturnType<typeof stopDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof stopDatabaseByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof stopDatabaseByUuid>>,
          TError,
          Awaited<ReturnType<typeof stopDatabaseByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStopDatabaseByUuid<
  TData = Awaited<ReturnType<typeof stopDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof stopDatabaseByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof stopDatabaseByUuid>>,
          TError,
          Awaited<ReturnType<typeof stopDatabaseByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStopDatabaseByUuid<
  TData = Awaited<ReturnType<typeof stopDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof stopDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Stop
 */

export function useStopDatabaseByUuid<
  TData = Awaited<ReturnType<typeof stopDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof stopDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getStopDatabaseByUuidQueryOptions(uuid, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Stop
 */
export const prefetchStopDatabaseByUuidQuery = async <
  TData = Awaited<ReturnType<typeof stopDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  queryClient: QueryClient,
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof stopDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getStopDatabaseByUuidQueryOptions(uuid, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getStopDatabaseByUuidSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof stopDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof stopDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStopDatabaseByUuidQueryKey(uuid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof stopDatabaseByUuid>>
  > = ({ signal }) => stopDatabaseByUuid(uuid, { signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof stopDatabaseByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StopDatabaseByUuidSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof stopDatabaseByUuid>>
>;
export type StopDatabaseByUuidSuspenseQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useStopDatabaseByUuidSuspense<
  TData = Awaited<ReturnType<typeof stopDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof stopDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStopDatabaseByUuidSuspense<
  TData = Awaited<ReturnType<typeof stopDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof stopDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStopDatabaseByUuidSuspense<
  TData = Awaited<ReturnType<typeof stopDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof stopDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Stop
 */

export function useStopDatabaseByUuidSuspense<
  TData = Awaited<ReturnType<typeof stopDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof stopDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getStopDatabaseByUuidSuspenseQueryOptions(uuid, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Restart database. `Post` request is also accepted.
 * @summary Restart
 */
export type restartDatabaseByUuidResponse200 = {
  data: RestartDatabaseByUuid200;
  status: 200;
};

export type restartDatabaseByUuidResponse400 = {
  data: NHttp400Response;
  status: 400;
};

export type restartDatabaseByUuidResponse401 = {
  data: NHttp401Response;
  status: 401;
};

export type restartDatabaseByUuidResponse404 = {
  data: NHttp404Response;
  status: 404;
};

export type restartDatabaseByUuidResponseSuccess =
  restartDatabaseByUuidResponse200 & {
    headers: Headers;
  };
export type restartDatabaseByUuidResponseError = (
  | restartDatabaseByUuidResponse400
  | restartDatabaseByUuidResponse401
  | restartDatabaseByUuidResponse404
) & {
  headers: Headers;
};

export type restartDatabaseByUuidResponse =
  | restartDatabaseByUuidResponseSuccess
  | restartDatabaseByUuidResponseError;

export const getRestartDatabaseByUuidUrl = (uuid: string) => {
  return `/api/coolify/databases/${uuid}/restart`;
};

export const restartDatabaseByUuid = async (
  uuid: string,
  options?: RequestInit,
): Promise<restartDatabaseByUuidResponse> => {
  const res = await fetch(getRestartDatabaseByUuidUrl(uuid), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: restartDatabaseByUuidResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as restartDatabaseByUuidResponse;
};

export const getRestartDatabaseByUuidQueryKey = (uuid?: string) => {
  return [`/api/coolify/databases/${uuid}/restart`] as const;
};

export const getRestartDatabaseByUuidInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof restartDatabaseByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof restartDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRestartDatabaseByUuidQueryKey(uuid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof restartDatabaseByUuid>>
  > = ({ signal }) => restartDatabaseByUuid(uuid, { signal, ...fetchOptions });

  return {
    enabled: !!uuid,
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof restartDatabaseByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RestartDatabaseByUuidInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof restartDatabaseByUuid>>
>;
export type RestartDatabaseByUuidInfiniteQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useRestartDatabaseByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof restartDatabaseByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof restartDatabaseByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof restartDatabaseByUuid>>,
          TError,
          Awaited<ReturnType<typeof restartDatabaseByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRestartDatabaseByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof restartDatabaseByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof restartDatabaseByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof restartDatabaseByUuid>>,
          TError,
          Awaited<ReturnType<typeof restartDatabaseByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRestartDatabaseByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof restartDatabaseByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof restartDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Restart
 */

export function useRestartDatabaseByUuidInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof restartDatabaseByUuid>>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof restartDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRestartDatabaseByUuidInfiniteQueryOptions(
    uuid,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Restart
 */
export const prefetchRestartDatabaseByUuidInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof restartDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  queryClient: QueryClient,
  uuid: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof restartDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getRestartDatabaseByUuidInfiniteQueryOptions(
    uuid,
    options,
  );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const getRestartDatabaseByUuidQueryOptions = <
  TData = Awaited<ReturnType<typeof restartDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof restartDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRestartDatabaseByUuidQueryKey(uuid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof restartDatabaseByUuid>>
  > = ({ signal }) => restartDatabaseByUuid(uuid, { signal, ...fetchOptions });

  return {
    enabled: !!uuid,
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof restartDatabaseByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RestartDatabaseByUuidQueryResult = NonNullable<
  Awaited<ReturnType<typeof restartDatabaseByUuid>>
>;
export type RestartDatabaseByUuidQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useRestartDatabaseByUuid<
  TData = Awaited<ReturnType<typeof restartDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof restartDatabaseByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof restartDatabaseByUuid>>,
          TError,
          Awaited<ReturnType<typeof restartDatabaseByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRestartDatabaseByUuid<
  TData = Awaited<ReturnType<typeof restartDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof restartDatabaseByUuid>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof restartDatabaseByUuid>>,
          TError,
          Awaited<ReturnType<typeof restartDatabaseByUuid>>
        >,
        "initialData"
      >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRestartDatabaseByUuid<
  TData = Awaited<ReturnType<typeof restartDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof restartDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Restart
 */

export function useRestartDatabaseByUuid<
  TData = Awaited<ReturnType<typeof restartDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof restartDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRestartDatabaseByUuidQueryOptions(uuid, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Restart
 */
export const prefetchRestartDatabaseByUuidQuery = async <
  TData = Awaited<ReturnType<typeof restartDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  queryClient: QueryClient,
  uuid: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof restartDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
): Promise<QueryClient> => {
  const queryOptions = getRestartDatabaseByUuidQueryOptions(uuid, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getRestartDatabaseByUuidSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof restartDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof restartDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRestartDatabaseByUuidQueryKey(uuid);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof restartDatabaseByUuid>>
  > = ({ signal }) => restartDatabaseByUuid(uuid, { signal, ...fetchOptions });

  return {
    queryFn,
    queryKey,
    staleTime: 10000,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof restartDatabaseByUuid>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RestartDatabaseByUuidSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof restartDatabaseByUuid>>
>;
export type RestartDatabaseByUuidSuspenseQueryError =
  | NHttp400Response
  | NHttp401Response
  | NHttp404Response;

export function useRestartDatabaseByUuidSuspense<
  TData = Awaited<ReturnType<typeof restartDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof restartDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRestartDatabaseByUuidSuspense<
  TData = Awaited<ReturnType<typeof restartDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof restartDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRestartDatabaseByUuidSuspense<
  TData = Awaited<ReturnType<typeof restartDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof restartDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Restart
 */

export function useRestartDatabaseByUuidSuspense<
  TData = Awaited<ReturnType<typeof restartDatabaseByUuid>>,
  TError = NHttp400Response | NHttp401Response | NHttp404Response,
>(
  uuid: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof restartDatabaseByUuid>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRestartDatabaseByUuidSuspenseQueryOptions(
    uuid,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
